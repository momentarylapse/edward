/*
 * DataModel.cpp
 *
 *  Created on: 04.03.2012
 *      Author: michi
 */

#include "DataModel.h"
#include "../../Action/Action.h"
#include "../../Action/ActionManager.h"
#include "../../Edward.h"
#include "../../Action/Model/ActionModelAddVertex.h"
#include "../../Action/Model/ActionModelAddTriangle.h"
#include "../../Action/Model/ActionModelAddCube.h"
#include "../../Action/Model/ActionModelAddPlane.h"
#include "../../Action/Model/ActionModelAddCylinder.h"
#include "../../Action/Model/ActionModelAddBall.h"

#include "../../lib/nix/nix.h"



ModeModelMaterial::ModeModelMaterial()
{	reset();	}

void ModeModelMaterial::reset()
{
	TransparencyMode = TransparencyModeDefault;
	AlphaDestination = 0;
	AlphaSource = 0;
	AlphaFactor = 0;
	AlphaZBuffer = true;
	Shininess = 0;
	for (int i=0;i<8;i++)
		Color[i/4][i%4] = 255; // ambient, diffuse
	for (int i=0;i<8;i++)
		Color[i/4+2][i%4] = 0; // specular, emissive
	UserColor = false;
	MaterialFile = "";
	material = MetaLoadMaterial("");
	NumTextures = 1;
	TextureFile[0] = "";
	Texture[0] = -1;
}

void ModeModelMaterial::CheckTextures()
{
	if (material->num_textures > NumTextures){
		for (int i=NumTextures;i<material->num_textures;i++){
			TextureFile[i] = "";
			Texture[i] = -1;
		}
		NumTextures = material->num_textures;
		//Change();
		ed->SetMessage(_("Anzahl der Texturen wurde an das Material angepasst!"));
	}
	for (int i=0;i<material->num_textures;i++)
		if (Texture[i] < 0)
			if (TextureFile[i].num == 0)
				Texture[i] = material->texture[i];
}

void ModeModelMaterial::Apply()
{
	NixSetAlpha(AlphaNone);
	NixSetShader(-1);
	color c;
	color am=material->ambient;
	color di=material->diffuse;
	color sp=material->specular;
	color em=material->emission;
	float sh=material->shininess;
	if (UserColor){
		am=i42c(Color[0]);
		di=i42c(Color[1]);
		sp=i42c(Color[2]);
		em=i42c(Color[3]);
		sh=(float)Shininess;
	}
	em=ColorInterpolate(em,White,0.1f);
	NixSetMaterial(am,di,sp,sh,em);
	if (false){//MVFXEnabled){
		int tm,as,ad;
		bool az;
		float af;
		if (TransparencyMode==TransparencyModeDefault){
			tm=material->transparency_mode;
			as=material->alpha_source;
			ad=material->alpha_destination;
			af=material->alpha_factor;
			az=material->alpha_z_buffer;
		}else{
			tm=TransparencyMode;
			as=AlphaSource;
			ad=AlphaDestination;
			af=(float)AlphaFactor*0.01f;
			az=AlphaZBuffer;
		}
		NixSetZ(az,az);
		if (tm==TransparencyModeColorKeyHard)
			NixSetAlpha(AlphaColorKeyHard);
		else if (tm==TransparencyModeColorKeySmooth)
			NixSetAlpha(AlphaColorKeySmooth);
		else if (tm==TransparencyModeFunctions){
			NixSetAlpha(as,ad);
			//NixSetZ(false,false);
		}else if (tm==TransparencyModeFactor){
			NixSetAlpha(af);
			//NixSetZ(false,false);
		}
		NixSetShader(material->shader);
	}
}


DataModel::DataModel()
{
	action_manager = new ActionManager(this);
	AutoTexturingData.enabled = false;

	ViewStage = 0; // TODO: mode...?
}

DataModel::~DataModel()
{
}



void DataModel::Reset()
{

	filename = "";
	for (int i=0;i<4;i++){
		Skin[i].Vertex.clear();
		Skin[i].NormalModeAll = NormalModeAngular;
		for (int j=0;j<Material.num;j++)
			Skin[i].Sub[j].Triangle.clear();
		Skin[i].Sub.resize(1);
	}
	Surface.clear();
	Vertex.clear();
	Ball.clear();
	Poly.clear();
	DetailDist[0] = 2000;
	DetailDist[1] = 4000;
	DetailDist[2] = 8000;
	AutoGenerateDists = true;
	DetailFactor[1] = 40;
	DetailFactor[2] = 20;
	AutoGenerateSkin[1] = false;//true;
	AutoGenerateSkin[2] = false;//true;
	Fx.clear();
	Material.resize(1);
	Material[0].reset();
	AutoGenerateTensor=true;
	Matrix3Identity(InertiaTensor);

	CurrentMaterial = 0;
	CurrentTextureLevel = 0;

	SkinVertMat = SkinVertTL = -1;

	// skeleton
	Bone.clear();

	// create one dummy animation
	Move.resize(1);
	move = &Move[0];
	CurrentMove = 0;
	CurrentFrame = 0;
	move->Frame.num = 0;
	move->Type = MoveTypeNone;
	move->FramesPerSecConst = 1;
	move->FramesPerSecFactor = 0;
	move->InterpolatedQuadratic = 0;
	move->InterpolatedLoop = false;
	move->Name = "";
	TimeScale = 1;
	TimeParam = 0;
	Playing = false;
	PlayLoop = true;


	for (int i=0;i<4;i++){
		Skin[i].Sub.resize(1);
		Skin[i].Sub[0].NumTextures = 1;
	}


	// object data
	Name = "";
	Description = "";
	ScriptFile = "";
	Mass = 1;
	Radius = 42;
	ActivePhysics = true;
	PassivePhysics = true;
	Inventary.clear();
	ScriptVar.clear();

	ResetHistory();

	/*AddVertex(vector(0, 0, 0));
	AddVertex(vector(20, 0, 0));
	AddVertex(vector(20, 20, 0));
	AddVertex(vector(0, 20, 0));
	AddVertex(vector(0, 0, 10));

	AddTriangle(0, 2, 1);
	AddTriangle(0, 3, 2);*/
	Execute(new ActionModelAddCube(v0, e_x * 20, e_y * 20, e_z * 20, Vertex.num));
	/*Execute(new ActionModelAddPlane(e_y * 10, e_x * 200, e_z * 200, 4, 4, Vertex.num));
	Execute(new ActionModelAddBall(vector(-200, 0, 0), 100, 16, 16, false, Vertex.num));
	Execute(new ActionModelAddBall(vector(-200, 0, 200), 100, 16, 16, true, Vertex.num));
	Execute(new ActionModelAddCylinder(vector(200, 0, 0), e_z * 100, 40, 3, 16, true, Vertex.num));*/

	msg_write("------------");
	msg_write(Vertex.num);
	msg_write(Surface.num);
	foreach(Surface, s)
		msg_write(s.Triangle.num);
}



int get_normal_index(vector &n)
{
	int nxy, nz;
	if ((n.x == 0) && (n.y == 0)){
		nxy = 0;
		nz = (n.z < 0) ? 255 : 0;
	}else{
		nxy = (int)(atan2(n.y, n.x) / pi / 2 * 255.0f) & 255;
		nz = (int)(acos(n.z) / pi * 255.0f) & 255;
	}
	return nxy + 256 * nz;
}

vector get_normal_by_index(int index)
{
	float wz = (float)(index >> 8) * pi / 255.0f;
	float wxy = (float)(index & 255) * 2 * pi / 255.0f;
	float swz = sin(wz);
	if (swz < 0)
		swz = - swz;
	float cwz = cos(wz);
	return vector( cos(wxy) * swz, sin(wxy) * swz, cwz);
}



bool DataModel::Load(const string & _filename, bool deep)
{
	msg_db_r("Model::LoadFromFile",1);
	//if (allow_load)
	Reset();
	bool error=false;
	int ffv;

	Array<vector> skin_vert;

	filename = _filename;
	if (this == mode_model->data)
		ed->MakeDirs(filename);
	//msg_write(dir);
	//msg_write(filename);
	CFile *f=new CFile();
	if (!f->Open(filename)){
		delete(f);
		ed->SetMessage(_("Datei ist nicht in der Stimmung, ge&offnet zu werden"));
		msg_db_l(1);
		return false;
	}
	file_time = f->GetDate(FileDateModification).time;

	ffv=f->ReadFileFormatVersion();

	if (ffv<0){
		ed->ErrorBox(_("Datei-Format unlesbar!"));
		msg_db_l(1);
		error=true;

	}else if (ffv==10){ // old format

		// Materials
		Material.resize(f->ReadIntC());
		for (int i=0;i<Material.num;i++){
			Material[i].MaterialFile = f->ReadStr();
			Material[i].UserColor = f->ReadBool();
			if (Material[i].UserColor){
				for (int j=0;j<4;j++)
					read_color_4(f,Material[i].Color[j]);
				Material[i].Shininess = f->ReadInt();
			}
			Material[i].TransparencyMode = f->ReadInt();
			Material[i].AlphaSource = f->ReadInt();
			Material[i].AlphaDestination = f->ReadInt();
			Material[i].AlphaFactor = f->ReadInt();
			Material[i].AlphaZBuffer = f->ReadBool();
			Material[i].NumTextures = f->ReadInt();
			for (int t=0;t<Material[i].NumTextures;t++)
				Material[i].TextureFile[t] = f->ReadStr();
		}
		// create subs...
		for (int k=0;k<4;k++){
			Skin[k].Sub.resize(Material.num);
			for (int j=0;j<Material.num;j++)
				Skin[k].Sub[j].NumTextures = 1;
		}

	// Physical Skin

		// vertices
		Skin[0].Vertex.resize(f->ReadIntC());
		for (int j=0;j<Skin[0].Vertex.num;j++){
			Skin[0].Vertex[j].BoneIndex = f->ReadInt();
			if (Skin[0].Vertex[j].BoneIndex < 0)
				Skin[0].Vertex[j].BoneIndex = 0;
			f->ReadVector(&Skin[0].Vertex[j].pos);
		}

		// triangles
		Skin[0].Sub[0].Triangle.resize(f->ReadInt());
		for (int j=0;j<Skin[0].Sub[0].Triangle.num;j++){
			Skin[0].Sub[0].Triangle[j].NormalDirty = true;
			for (int k=0;k<3;k++)
				Skin[0].Sub[0].Triangle[j].Vertex[k] = f->ReadInt();
		}

		// balls
		Ball.resize(f->ReadInt());
		for (int j=0;j<Ball.num;j++){
			Ball[j].Index = f->ReadInt();
			Ball[j].Radius = f->ReadFloat();
		}

		// polys
		Poly.resize(f->ReadInt());
		for (int j=0;j<Poly.num;j++){
			Poly[j].NumFaces = f->ReadInt();
			for (int k=0;k<Poly[j].NumFaces;k++){
				Poly[j].Face[k].NumVertices = f->ReadInt();
				for (int l=0;l<Poly[j].Face[k].NumVertices;l++)
					Poly[j].Face[k].Index[l] = f->ReadInt();
			}
		}

	// Skin[i]
		for (int i=1;i<4;i++){
			Skin[i].NormalModeAll = f->ReadIntC();
			bool pre_normals = (Skin[i].NormalModeAll & NormalModePre) > 0;
			Skin[i].NormalModeAll -= (Skin[i].NormalModeAll & NormalModePre);

			// vertices
			Skin[i].Vertex.resize(f->ReadInt());
			for (int j=0;j<Skin[i].Vertex.num;j++){
				Skin[i].Vertex[j].BoneIndex = f->ReadInt();
				if (Skin[i].Vertex[j].BoneIndex < 0)
					Skin[i].Vertex[j].BoneIndex = 0;
				f->ReadVector(&Skin[i].Vertex[j].pos);
				if (Skin[i].NormalModeAll == NormalModePerVertex)
					Skin[i].Vertex[j].NormalMode = f->ReadByte();
				else
					Skin[i].Vertex[j].NormalMode = Skin[i].NormalModeAll;
				Skin[i].Vertex[j].NormalDirty = true;
			}

			// skin vertices
			skin_vert.resize(f->ReadInt());
			for (int j=0;j<skin_vert.num;j++){
				skin_vert[j].x = f->ReadFloat();
				skin_vert[j].y = f->ReadFloat();
			}



			// triangles (subs)
			int num_trias = f->ReadInt();
			for (int t=0;t<Material.num;t++)
				Skin[i].Sub[t].Triangle.resize(f->ReadInt());
			for (int t=0;t<Material.num;t++)
				for (int j=0;j<Skin[i].Sub[t].Triangle.num;j++)
					for (int k=0;k<3;k++){
						Skin[i].Sub[t].Triangle[j].Vertex[k] = f->ReadInt();
						int svi = f->ReadInt();
						Skin[i].Sub[t].Triangle[j].SkinVertex[0][k] = skin_vert[svi];
						Skin[i].Sub[t].Triangle[j].NormalIndex[k] = (int)f->ReadByte();
						Skin[i].Sub[t].Triangle[j].NormalDirty = true;
					}
		}

	// Skeleton
		Bone.resize(f->ReadIntC());
		for (int i=0;i<Bone.num;i++){
			f->ReadVector(&Bone[i].DeltaPos);
			Bone[i].Parent = f->ReadInt();
			if (Bone[i].Parent > 32000)
				Bone[i].Parent = -1;
			Bone[i].ModelFile = f->ReadStr();
			if (deep)
				Bone[i].model = MetaLoadModel(Bone[i].ModelFile);
			Bone[i].ConstPos = false;
			Bone[i].is_selected = Bone[i].m_old = false;
		}

	// Animations
		int num_anims = f->ReadIntC();
		for (int i=0;i<num_anims;i++){
			int anim_index = f->ReadInt();
			Move.resize(anim_index + 1);
			ModeModelMove *m = &Move[anim_index];
			m->Name = f->ReadStr();
			m->Type = f->ReadInt();
			m->Frame.resize(f->ReadInt());
			m->FramesPerSecConst = f->ReadFloat();
			m->FramesPerSecFactor = f->ReadFloat();

			// vertex animation
			if (m->Type == MoveTypeVertex){
				for (int fr=0;fr<m->Frame.num;fr++){
					for (int s=0;s<4;s++){
						m->Frame[fr].Skin[s].DPos.resize(Skin[s].Vertex.num);
						int num_vertices = f->ReadInt();
						for (int j=0;j<num_vertices;j++){
							int vertex_index = f->ReadInt();
							f->ReadVector(&m->Frame[fr].Skin[s].DPos[vertex_index]);
						}
					}
				}
			}else if (m->Type == MoveTypeSkeletal){
				Array<bool> VarDeltaPos;
				VarDeltaPos.resize(Bone.num);
				for (int j=0;j<Bone.num;j++)
					VarDeltaPos[j] = f->ReadBool();
				m->InterpolatedQuadratic = f->ReadBool();
				m->InterpolatedLoop = f->ReadBool();
				for (int fr=0;fr<m->Frame.num;fr++){
					m->Frame[fr].SkelDPos.resize(Bone.num);
					m->Frame[fr].SkelAng.resize(Bone.num);
					for (int j=0;j<Bone.num;j++){
						f->ReadVector(&m->Frame[fr].SkelAng[j]);
						if (VarDeltaPos[j])
							f->ReadVector(&m->Frame[fr].SkelDPos[j]);
					}
				}
			}
		}
		// Effects
		Fx.resize(f->ReadIntC());
		if (Fx.num>10000)
			Fx.clear();
		for (int i=0;i<Fx.num;i++){
			string fxkind = f->ReadStr();
			Fx[i].Kind = -1;
			if (fxkind == "Script"){
				Fx[i].Kind = FXKindScript;
				Fx[i].Vertex = f->ReadInt();
				Fx[i].File = f->ReadStr();
				Fx[i].Function = f->ReadStr();
			}
			if (fxkind == "Light"){
				Fx[i].Kind=FXKindLight;
				Fx[i].Vertex=f->ReadInt();
				Fx[i].Size=f->ReadInt();
				for (int j=0;j<3;j++)
					read_color_4(f,Fx[i].Colors[j]);
			}
			if (fxkind == "Sound"){
				Fx[i].Kind=FXKindSound;
				Fx[i].Vertex=f->ReadInt();
				Fx[i].Size=f->ReadInt();
				Fx[i].Speed=f->ReadInt();
				Fx[i].File=f->ReadStr();
			}
			if (fxkind == "ForceField"){
				Fx[i].Kind=FXKindForceField;
				Fx[i].Vertex=f->ReadInt();
				Fx[i].Size=f->ReadInt();
				Fx[i].Intensity=f->ReadInt();
				Fx[i].InvQuad=f->ReadBool();
			}
			if (Fx[i].Kind<0)
				msg_error("unknown effekt: " + fxkind);
		}
		// LOD-Distances
		DetailDist[0]=f->ReadFloatC();
		DetailDist[1]=f->ReadFloat();
		DetailDist[2]=f->ReadFloat();
		AutoGenerateDists=f->ReadBool();
		DetailFactor[1]=f->ReadByte();
		DetailFactor[2]=f->ReadByte();
		AutoGenerateSkin[1]=f->ReadBool();
		AutoGenerateSkin[2]=f->ReadBool();
		// Physics
		AutoGenerateTensor = f->ReadBoolC();
		for (int i=0;i<9;i++)
			InertiaTensor.e[i] = f->ReadFloat();
		// BG Textures
		/*if (strcmp(f->ReadStr(),"#")!=0){
			for (int i=0;i<4;i++){
				char sss[512];
				strcpy(sss,f->ReadStr());
				if (strlen(sss)>0){
					strcpy(BgTextureFile[i],sss);
					if (allow_load)
						BgTexture[i]=NixLoadTexture(sss);
					BgTextureA[i].x=f->ReadFloat();
					BgTextureA[i].y=f->ReadFloat();
					BgTextureA[i].z=f->ReadFloat();
					BgTextureB[i].x=f->ReadFloat();
					BgTextureB[i].y=f->ReadFloat();
					BgTextureB[i].z=f->ReadFloat();
				}
			}
		}*/

		// correction
		/*skin=&Skin[1];
		SetNormalMode(NormalModeAngular,true);
		skin=&Skin[2];
		SetNormalMode(NormalModeAngular,true);
		skin=&Skin[3];
		SetNormalMode(NormalModeAngular,true);
		AlphaZBuffer=(TransparencyMode!=TransparencyModeFunctions)&&(TransparencyMode!=TransparencyModeFactor);*/


	}else if (ffv==11){ // new format


		// General
		vector tv;
		f->ReadComment();
		// bounding box
		f->ReadVector(&tv);
		f->ReadVector(&tv);
		// skins
		f->ReadInt();
		// reserved
		f->ReadInt();
		f->ReadInt();
		f->ReadInt();
		//

		// Materials
		Material.resize(f->ReadIntC());
		for (int i=0;i<Material.num;i++){
			Material[i].MaterialFile = f->ReadStr();
			Material[i].UserColor = f->ReadBool();
			for (int j=0;j<4;j++)
				read_color_4(f,Material[i].Color[j]);
			Material[i].Shininess = f->ReadInt();
			Material[i].TransparencyMode = f->ReadInt();
			Material[i].AlphaSource = f->ReadInt();
			Material[i].AlphaDestination = f->ReadInt();
			Material[i].AlphaFactor = f->ReadInt();
			Material[i].AlphaZBuffer = f->ReadBool();
			Material[i].NumTextures = f->ReadInt();
			for (int t=0;t<Material[i].NumTextures;t++)
				Material[i].TextureFile[t] = f->ReadStr();
		}
		// create subs...
		for (int k=0;k<4;k++){
			Skin[k].Sub.resize(Material.num);
			for (int j=0;j<Material.num;j++)
				Skin[k].Sub[j].NumTextures = Material[j].NumTextures;
		}

	// Physical Skin

		// vertices
		Skin[0].Vertex.resize(f->ReadIntC());
		for (int j=0;j<Skin[0].Vertex.num;j++)
			Skin[0].Vertex[j].BoneIndex = f->ReadInt();
		for (int j=0;j<Skin[0].Vertex.num;j++)
			f->ReadVector(&Skin[0].Vertex[j].pos);

		// triangles
		f->ReadInt();

		// balls
		Ball.resize(f->ReadInt());
		for (int j=0;j<Ball.num;j++){
			Ball[j].Index = f->ReadInt();
			Ball[j].Radius = f->ReadFloat();
		}

		// polys
		Poly.resize(f->ReadInt());
		for (int j=0;j<Poly.num;j++){
			Poly[j].NumFaces = f->ReadInt();
			for (int k=0;k<Poly[j].NumFaces;k++){
				Poly[j].Face[k].NumVertices = f->ReadInt();
				for (int l=0;l<Poly[j].Face[k].NumVertices;l++)
					Poly[j].Face[k].Index[l] = f->ReadInt();
				f->ReadFloat();
				f->ReadFloat();
				f->ReadFloat();
				f->ReadFloat();
			}
			Poly[j].NumSVertices = f->ReadInt();
			for (int k=0;k<Poly[j].NumSVertices;k++)
				f->ReadInt();
			Poly[j].NumEdges = f->ReadInt();
			for (int k=0;k<Poly[j].NumEdges*2;k++)
				f->ReadInt();
			// topology
			for (int k=0;k<Poly[j].NumFaces*Poly[j].NumFaces;k++)
				f->ReadInt();
			for (int k=0;k<Poly[j].NumEdges*Poly[j].NumFaces;k++)
				f->ReadBool();
		}

	// Skin[i]
		for (int i=1;i<4;i++){

			// vertices
			Skin[i].Vertex.resize(f->ReadIntC());
			for (int j=0;j<Skin[i].Vertex.num;j++)
				f->ReadVector(&Skin[i].Vertex[j].pos);
			for (int j=0;j<Skin[i].Vertex.num;j++)
				Skin[i].Vertex[j].BoneIndex = f->ReadInt();
			for (int j=0;j<Skin[i].Vertex.num;j++)
				Skin[i].Vertex[j].NormalDirty = false;//true;

			// skin vertices
			skin_vert.resize(f->ReadInt());
			for (int j=0;j<skin_vert.num;j++){
				skin_vert[j].x = f->ReadFloat();
				skin_vert[j].y = f->ReadFloat();
			}



			// triangles (subs)
			for (int m=0;m<Material.num;m++){
				Skin[i].Sub[m].Triangle.resize(f->ReadInt());
				// vertex
				for (int j=0;j<Skin[i].Sub[m].Triangle.num;j++)
					for (int k=0;k<3;k++)
						Skin[i].Sub[m].Triangle[j].Vertex[k] = f->ReadInt();
				// skin vertex
				for (int tl=0;tl<Material[m].NumTextures;tl++)
					for (int j=0;j<Skin[i].Sub[m].Triangle.num;j++)
						for (int k=0;k<3;k++){
							int svi = f->ReadInt();
							Skin[i].Sub[m].Triangle[j].SkinVertex[tl][k] = skin_vert[svi];
						}
				// normals
				for (int j=0;j<Skin[i].Sub[m].Triangle.num;j++){
					for (int k=0;k<3;k++){
						Skin[i].Sub[m].Triangle[j].NormalIndex[k] = (int)(unsigned short)f->ReadWord();
						Skin[i].Sub[m].Triangle[j].Normal[k] = get_normal_by_index(Skin[i].Sub[m].Triangle[j].NormalIndex[k]);
					}
					Skin[i].Sub[m].Triangle[j].NormalDirty = false;
				}
				f->ReadInt();
			}
			f->ReadInt();
		}

	// Skeleton
		Bone.resize(f->ReadIntC());
		for (int i=0;i<Bone.num;i++){
			f->ReadVector(&Bone[i].DeltaPos);
			Bone[i].Parent = f->ReadInt();
			Bone[i].ModelFile = f->ReadStr();
			if (deep)
				Bone[i].model = MetaLoadModel(Bone[i].ModelFile);
			Bone[i].ConstPos = false;
			Bone[i].is_selected = Bone[i].m_old = false;
		}

	// Animations
		Move.resize(f->ReadIntC());
		int num_anims = f->ReadInt();
		f->ReadInt();
		f->ReadInt();
		for (int i=0;i<num_anims;i++){
			int anim_index = f->ReadInt();
			Move.resize(anim_index + 1);
			ModeModelMove *m = &Move[anim_index];
			m->Name = f->ReadStr();
			m->Type = f->ReadInt();
			m->Frame.resize(f->ReadInt());
			m->FramesPerSecConst = f->ReadFloat();
			m->FramesPerSecFactor = f->ReadFloat();

			// vertex animation
			if (m->Type == MoveTypeVertex){
				for (int fr=0;fr<m->Frame.num;fr++){
					for (int s=0;s<4;s++){
						m->Frame[fr].Skin[s].DPos.resize(Skin[s].Vertex.num);
						int num_vertices = f->ReadInt();
						for (int j=0;j<num_vertices;j++){
							int vertex_index = f->ReadInt();
							f->ReadVector(&m->Frame[fr].Skin[s].DPos[vertex_index]);
						}
					}
				}
			}else if (m->Type == MoveTypeSkeletal){
				Array<bool> VarDeltaPos;
				VarDeltaPos.resize(Bone.num);
				for (int j=0;j<Bone.num;j++)
					VarDeltaPos[j] = f->ReadBool();
				m->InterpolatedQuadratic = f->ReadBool();
				m->InterpolatedLoop = f->ReadBool();
				for (int fr=0;fr<m->Frame.num;fr++){
					m->Frame[fr].SkelDPos.resize(Bone.num);
					m->Frame[fr].SkelAng.resize(Bone.num);
					for (int j=0;j<Bone.num;j++){
						f->ReadVector(&m->Frame[fr].SkelAng[j]);
						if (VarDeltaPos[j])
							f->ReadVector(&m->Frame[fr].SkelDPos[j]);
					}
				}
			}
		}
		// Effects
		Fx.resize(f->ReadIntC());
		if (Fx.num>10000)
			Fx.clear();
		for (int i=0;i<Fx.num;i++){
			string fxkind = f->ReadStr();
			Fx[i].Kind=-1;
			if (fxkind == "Script"){
				Fx[i].Kind = FXKindScript;
				Fx[i].Vertex = f->ReadInt();
				Fx[i].File = f->ReadStr();
				Fx[i].Function = f->ReadStr();
			}
			if (fxkind == "Light"){
				Fx[i].Kind=FXKindLight;
				Fx[i].Vertex=f->ReadInt();
				Fx[i].Size=f->ReadInt();
				for (int j=0;j<3;j++)
					read_color_4(f,Fx[i].Colors[j]);
			}
			if (fxkind == "Sound"){
				Fx[i].Kind = FXKindSound;
				Fx[i].Vertex = f->ReadInt();
				Fx[i].Size = f->ReadInt();
				Fx[i].Speed = f->ReadInt();
				Fx[i].File = f->ReadStr();
			}
			if (fxkind == "ForceField"){
				Fx[i].Kind = FXKindForceField;
				Fx[i].Vertex = f->ReadInt();
				Fx[i].Size = f->ReadInt();
				Fx[i].Intensity = f->ReadInt();
				Fx[i].InvQuad = f->ReadBool();
			}
			if (Fx[i].Kind<0)
				msg_error("unknown effekt: " + fxkind);
		}

// properties
		// Physics
		Mass = f->ReadFloatC();
		for (int i=0;i<9;i++)
			InertiaTensor.e[i] = f->ReadFloat();
		ActivePhysics = f->ReadBool();
		PassivePhysics = f->ReadBool();
		Radius = f->ReadFloat();

		// LOD-Distances
		DetailDist[0] = f->ReadFloatC();
		DetailDist[1] = f->ReadFloat();
		DetailDist[2] = f->ReadFloat();

// object data
		// Object Data
		Name = f->ReadStrC();
		Description = f->ReadStr();

		// Inventary
		Inventary.resize(f->ReadIntC());
		for (int i=0;i<Inventary.num;i++){
		    Inventary[i] = f->ReadStr();
			f->ReadInt();
		}

		// Script
		ScriptFile = f->ReadStrC();
		ScriptVar.resize(f->ReadInt());
		for (int i=0;i<ScriptVar.num;i++)
		    ScriptVar[i] = f->ReadFloat();


// additional data for editing
		// Editor
		AutoGenerateTensor = f->ReadBoolC();
		AutoGenerateDists = f->ReadBool();
		AutoGenerateSkin[1] = f->ReadBool();
		AutoGenerateSkin[2] = f->ReadBool();
		DetailFactor[1] = f->ReadInt();
		DetailFactor[2] = f->ReadInt();
		// Normals
		f->ReadComment();
		for (int i=1;i<4;i++){
			ModeModelSkin *s = &Skin[i];
			s->NormalModeAll = f->ReadInt();
			if (s->NormalModeAll == NormalModePerVertex){
				foreach(s->Vertex, v)
					v.NormalMode = f->ReadInt();
			}else{
				foreach(s->Vertex, v)
					v.NormalMode = s->NormalModeAll;
			}
		   }
		// BG Textures
		f->ReadComment();
	/*for (int i=0;i<4;i++){
		f->WriteStr(BgTextureFile[i]);
		if (strlen(BgTextureFile[i])>0){
			f->WriteFloat(BgTextureA[i].x);
			f->WriteFloat(BgTextureA[i].y);
			f->WriteFloat(BgTextureA[i].z);
			f->WriteFloat(BgTextureB[i].x);
			f->WriteFloat(BgTextureB[i].y);
			f->WriteFloat(BgTextureB[i].z);
		}
	}*/





	}else{
		ed->ErrorBox(format(_("Falsches Datei-Format der Datei '%s': %d (statt %d - %d)"), filename.c_str(), ffv, 10, 10));
		error=true;
	}

	f->Close();
	delete(f);




		// import...
		foreach(Skin[1].Vertex, v)
			AddVertex(v.pos);
		for (int i=0;i<Material.num;i++){
			CurrentMaterial = i;
			foreach(Skin[1].Sub[i].Triangle, t){
				ModeModelTriangle *tt = AddTriangle(t.Vertex[0], t.Vertex[1], t.Vertex[2]);
				for (int tl=0;tl<Material[i].NumTextures;tl++)
					for (int k=0;k<3;k++)
						tt->SkinVertex[tl][k] = t.SkinVertex[tl][k];
			}
		}



	if (deep){
		for (int i=0;i<Material.num;i++){
			Material[i].material = MetaLoadMaterial(Material[i].MaterialFile);
			for (int t=0;t<Material[i].NumTextures;t++){
				Material[i].Texture[t] = NixLoadTexture(Material[i].TextureFile[t]);
				if ((Material[i].Texture[t] < 0) && (Material[i].TextureFile[t].num > 0))
					ed->SetMessage(format(_("Textur-Datei nicht ladbar: %s"), Material[i].TextureFile[t].c_str()));
			}
			Material[i].CheckTextures();
		}



		// TODO -> mode...
		/*if (this == mode_model->data){
			ed->SetTitle(filename);
			ResetView();
		}*/
	}


	//OptimizeView();
	ResetHistory();

	UpdateNormals();
	msg_db_l(1);
	return !error;
}



void DataModel::Save(const string & _filename)
{
}


void DataModel::UpdateNormals()
{
}

ModeModelSurface *DataModel::AddSurface()
{
	Surface.resize(Surface.num + 1);
	ModeModelSurface *s = &Surface.back();
	s->view_stage = ViewStage;
	s->is_selected = false;
	s->IsClosed = false;
	s->IsVisible = true;
	s->IsPhysical = true;
	return s;
}


void DataModel::AddVertex(const vector &v)
{	Execute(new ActionModelAddVertex(v));	}

ModeModelTriangle *DataModel::AddTriangle(int a, int b, int c)
{
	vector sv[3] = {e_y, v0, e_x};
	//ApplyAutoTexturing(this, a, b, c, sv);
	return (ModeModelTriangle*) Execute(new ActionModelAddTriangle(a, b, c, sv[0], sv[1], sv[2]));
}





void SurfaceTestSanity(ModeModelSurface *s, const string &loc)
{
	foreach(s->Triangle, t)
		if ((t.Vertex[0] == t.Vertex[1]) || (t.Vertex[1] == t.Vertex[2]) || (t.Vertex[2] == t.Vertex[0])){
			msg_error(loc + ": surf broken!   tria");
			return;
		}
	foreach(s->Edge, e)
		if (e.Vertex[0] == e.Vertex[1]){
			msg_error(loc + ": surf broken!   edge");
			return;
		}
}

int get_surf_no(DataModel *m, ModeModelSurface *s)
{
	foreachi(m->Surface, ss, i)
		if (&ss == s)
			return i;
	return -1;
}

ModeModelSurface *DataModel::SurfaceJoin(ModeModelSurface *a, ModeModelSurface *b)
{
	msg_db_r("SurfJoin", 1);

	SurfaceTestSanity(a, "Join prae a");
	SurfaceTestSanity(b, "Join prae b");

	int ai = get_surf_no(this, a);
	int bi = get_surf_no(this, b);

	// correct edge data of b
	foreach(b->Edge, e){
		if (e.Triangle[0] >= 0)
			e.Triangle[0] += a->Triangle.num;
		if (e.Triangle[1] >= 0)
			e.Triangle[1] += a->Triangle.num;
	}

	// correct triangle data of b
	foreach(b->Triangle, t)
		for (int k=0;k<3;k++)
			t.Edge[k] += a->Edge.num;

	// correct vertex data of b
	foreach(b->Vertex, v)
		Vertex[v].Surface = ai;

	// insert data
	a->Vertex.join(b->Vertex);
	a->Edge.append(b->Edge);
	a->Triangle.append(b->Triangle);

	// remove surface
	if (bi >= 0)
		Surface.erase(bi);
	a = &Surface[ai];
	SurfaceTestSanity(a, "Join post a");

	msg_db_l(1);
	return a;
}

void ModeModelSurface::AddVertex(int v, DataModel *m)
{
	// set -> unique
	Vertex.add(v);

	// back reference
	m->Vertex[v].Surface = get_surf_no(m, this);
	if (m->Vertex[v].Surface < 0)
		msg_error("SurfaceAddVertex ...surface not found");
}

void ModeModelSurface::AddTriangle(int a, int b, int c, const vector &sa, const vector &sb, const vector &sc, DataModel *m)
{
	msg_db_r("Surf.AddTria", 1);

	ModeModelTriangle t;
	t.Vertex[0] = a;
	t.Vertex[1] = b;
	t.Vertex[2] = c;
	for (int i=0;i<m->Material[m->CurrentMaterial].NumTextures;i++){
		t.SkinVertex[i][0] = sa;
		t.SkinVertex[i][1] = sb;
		t.SkinVertex[i][2] = sc;
	}
	for (int k=0;k<3;k++)
		t.Edge[k] = AddEdgeForNewTriangle(t.Vertex[k], t.Vertex[(k + 1) % 3]);
	AddVertex(a, m);
	AddVertex(b, m);
	AddVertex(c, m);

	// closed?
	UpdateClosed();

	// ref count
	m->Vertex[a].RefCount ++;
	m->Vertex[b].RefCount ++;
	m->Vertex[c].RefCount ++;

	t.is_selected = false;
	t.Material = m->CurrentMaterial;
	t.view_stage = m->ViewStage;
	t.NormalDirty = true;
	Triangle.add(t);
	msg_db_l(1);
}

int ModeModelSurface::AddEdgeForNewTriangle(int a, int b)
{
	int tria = Triangle.num;
	foreachi(Edge, e, i){
		if ((e.Vertex[0] == a) && (e.Vertex[1] == b)){
			e.RefCount ++;
			msg_error("surface error? inverse edge");
			e.Triangle[1] = tria;
			return i;
		}
		if ((e.Vertex[0] == b) && (e.Vertex[1] == a)){
			e.RefCount ++;
			if (e.RefCount > 2)
				msg_error("surface error? edge refcount > 2");
			e.Triangle[1] = tria;
			return i;
		}
	}
	ModeModelEdge ee;
	ee.Vertex[0] = a;
	ee.Vertex[1] = b;
	ee.is_selected = false;
	ee.is_special = false;
	ee.IsRound = false;
	ee.NormalMode = NormalModeAngular;
	ee.RefCount = 1;
	ee.Triangle[0] = tria;
	ee.Triangle[1] = -1;
	Edge.add(ee);
	return Edge.num - 1;
}


inline bool edge_equal(ModeModelEdge *e, int a, int b)
{
	return (((e->Vertex[0] == a) && (e->Vertex[1] == b)) || ((e->Vertex[0] == b) && (e->Vertex[1] == a)));
}

inline int find_other_tria_from_edge(ModeModelSurface *s, int e, int t)
{
	if (s->Edge[e].Triangle[0] == t)
		return s->Edge[e].Triangle[1];
	return s->Edge[e].Triangle[0];
}

// return: closed circle... don't run again to the left
inline bool find_tria_top(ModeModelSurface *s, const Array<int> &ti, const Array<int> &tv, Set<int> &used, bool to_the_right)
{
	int t0 = 0;
	while(true){
		int ne = tv[t0];
		if (!to_the_right)
			ne = (ne + 2) % 3;
		int e = s->Triangle[ti[t0]].Edge[ne];
		if (!s->Edge[e].IsRound)
			return false;
		int tt = find_other_tria_from_edge(s, e, ti[t0]);
		if (tt < 0)
			return false;
		t0 = -1;
		for (int i=0;i<ti.num;i++)
			if (ti[i] == tt)
				t0 = i;
		if (t0 <= 0)
			return (t0 == 0);
		used.add(t0);
	}
}


void ModeModelSurface::UpdateClosed()
{
	// closed?
	IsClosed = true;
	foreach(Edge, e)
		if (e.RefCount != 2){
			IsClosed = false;
			break;
		}
}

void ModeModelSurface::RemoveObsoleteEdge(int index)
{
	msg_db_r("Surf.RemoveObsoleteEdge", 2);
	// correct triangle references
	foreach(Triangle, t)
		for (int k=0;k<3;k++)
			if (t.Edge[k] > index)
				t.Edge[k] --;
			else if (t.Edge[k] == index)
				msg_error(format("surf rm edge: edge not really obsolete  rc=%d (%d,%d) (%d,%d)", Edge[index].RefCount, t.Vertex[k], t.Vertex[(k+1)%3], Edge[index].Vertex[0], Edge[index].Vertex[1]));

	// delete
	Edge.erase(index);
	msg_db_l(2);
}

void ModeModelSurface::MergeEdges()
{
	msg_db_r("Surf.MergeEdges", 1);

	SurfaceTestSanity(this, "MergeEdges prae");

	foreachi(Edge, e, i){
		for (int j=i+1;j<Edge.num;j++){
			ModeModelEdge &f = Edge[j];
			if (edge_equal(&e, f.Vertex[0], f.Vertex[1])){
				if (e.RefCount + f.RefCount > 2)
					msg_error(format("SurfMergeEdges: edge(%d,%d).RefCount...  %d + %d    tria=(%d,%d,%d,%d)", f.Vertex[0], f.Vertex[1], e.RefCount, f.RefCount, e.Triangle[0], e.Triangle[1], f.Triangle[0], f.Triangle[1]));

				e.RefCount ++;
				e.Triangle[1] = f.Triangle[0];

				// relink triangles
				for (int k=0;k<3;k++)
					if (Triangle[e.Triangle[1]].Edge[k] == j)
						Triangle[e.Triangle[1]].Edge[k] = i;
				RemoveObsoleteEdge(j);
				break;
			}
		}
	}
	SurfaceTestSanity(this, "MergeEdges post");
	msg_db_l(1);
}

void DataModel::ResetAutoTexturing()
{
	if (AutoTexturingData.enabled)
		CurrentMaterial = AutoTexturingData.prev_material;
	AutoTexturingData.enabled = false;
}

void DataModel::ApplyAutoTexturing(int a, int b, int c, vector *sv)
{
	if (AutoTexturingData.enabled){
		vector v[3];
		v[0] = Vertex[a].pos;
		v[1] = Vertex[b].pos;
		v[2] = Vertex[c].pos;
		for (int k=0;k<3;k++)
			sv[k] = vector( (v[k] - AutoTexturingData.p0) * AutoTexturingData.dir_u, (v[k] - AutoTexturingData.p0) * AutoTexturingData.dir_v, 0);
	}
}
