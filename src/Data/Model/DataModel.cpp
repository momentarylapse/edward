/*
 * DataModel.cpp
 *
 *  Created on: 04.03.2012
 *      Author: michi
 */

#include "DataModel.h"
#include "ModelSurface.h"
#include "Geometry/ModelGeometry.h"
#include "../../Mode/Model/ModeModel.h"
#include "../../Action/Action.h"
#include "../../Action/ActionManager.h"
#include "../../Edward.h"
#include "../../x/model_manager.h"
#include "../../Action/Model/Mesh/Vertex/ActionModelAddVertex.h"
#include "../../Action/Model/Mesh/Vertex/ActionModelNearifyVertices.h"
#include "../../Action/Model/Mesh/Vertex/ActionModelCollapseVertices.h"
#include "../../Action/Model/Mesh/Vertex/ActionModelAlignToGrid.h"
#include "../../Action/Model/Mesh/Vertex/ActionModelFlattenVertices.h"
#include "../../Action/Model/Mesh/Polygon/ActionModelBevelPolygons.h"
#include "../../Action/Model/Mesh/Polygon/ActionModelAddPolygonSingleTexture.h"
#include "../../Action/Model/Mesh/Polygon/ActionModelExtrudePolygons.h"
#include "../../Action/Model/Mesh/Polygon/ActionModelTriangulateSelection.h"
#include "../../Action/Model/Mesh/Polygon/ActionModelMergePolygonsSelection.h"
#include "../../Action/Model/Mesh/Polygon/ActionModelCutOutPolygons.h"
#include "../../Action/Model/Mesh/Shape/ActionModelAddCube.h"
#include "../../Action/Model/Mesh/Shape/ActionModelAddPlane.h"
#include "../../Action/Model/Mesh/Shape/ActionModelAddCylinder.h"
#include "../../Action/Model/Mesh/Shape/ActionModelAddBall.h"
#include "../../Action/Model/Mesh/Shape/ActionModelAddSphere.h"
#include "../../Action/Model/Mesh/Shape/ActionModelAddTorus.h"
#include "../../Action/Model/Mesh/Shape/ActionModelAddPlatonic.h"
#include "../../Action/Model/Mesh/Surface/ActionModelSurfaceSubtract.h"
#include "../../Action/Model/Mesh/Surface/ActionModelSurfaceInvert.h"
#include "../../Action/Model/Mesh/Surface/ActionModelAutoWeldSelection.h"
#include "../../Action/Model/Mesh/Surface/ActionModelSurfacesSubdivide.h"
#include "../../Action/Model/Mesh/Skin/ActionModelAutomap.h"
#include "../../Action/Model/Mesh/Look/ActionModelSetMaterial.h"
#include "../../Action/Model/Mesh/Look/ActionModelSetNormalModeSelection.h"
#include "../../Action/Model/Mesh/Look/ActionModelSetNormalModeAll.h"
#include "../../Action/Model/Mesh/Effects/ActionModelAddEffects.h"
#include "../../Action/Model/Mesh/Effects/ActionModelClearEffects.h"
#include "../../Action/Model/Mesh/Effects/ActionModelEditEffect.h"
#include "../../Action/Model/Mesh/ActionModelDeleteSelection.h"
#include "../../Action/Model/Mesh/ActionModelPasteGeometry.h"
#include "../../Action/Model/Mesh/ActionModelEasify.h"
#include "../../Action/Model/Animation/ActionModelAddAnimation.h"
#include "../../Action/Model/Animation/ActionModelDeleteAnimation.h"
#include "../../Action/Model/Animation/ActionModelAnimationAddFrame.h"
#include "../../Action/Model/Animation/ActionModelAnimationDeleteFrame.h"

ModelMove *EmptyMove = NULL;



string ModelEffect::get_type()
{
	if (Kind==FXKindScript)
		return _("Script");
	if (Kind==FXKindLight)
		return _("Licht");
	if (Kind==FXKindSound)
		return _("Sound");
	if (Kind==FXKindForceField)
		return _("Kraftfeld");
	return "???";
}

void ModelEffect::clear()
{
	File = "";
	Colors[0] = White;
	Colors[1] = White;
	Colors[2] = White;
	Size = 1000.0f;
	Speed = 1.0f;
	Intensity = 100.0f;
	InvQuad = false;
}


DataModel::DataModel() :
	Data(FDModel)
{
	AutoTexturingData.enabled = false;

	if (!EmptyMove){
		// create one dummy animation
		EmptyMove = new ModelMove;
		EmptyMove->Name = "-empty move-";
		EmptyMove->Type = MoveTypeNone;
		EmptyMove->Frame.resize(1);
		EmptyMove->FramesPerSecConst = 1;
		EmptyMove->FramesPerSecFactor = 0;
		EmptyMove->InterpolatedQuadratic = 0;
		EmptyMove->InterpolatedLoop = false;
	}
}

DataModel::~DataModel()
{
}


void DataModel::MetaData::Reset()
{
	// level of detail
	DetailDist[0] = 2000;
	DetailDist[1] = 4000;
	DetailDist[2] = 8000;
	AutoGenerateDists = true;
	DetailFactor[1] = 40;
	DetailFactor[2] = 20;
	AutoGenerateSkin[1] = false;//true;
	AutoGenerateSkin[2] = false;//true;

	// physics
	Mass = 1;
	ActivePhysics = true;
	PassivePhysics = true;
	AutoGenerateTensor = true;
	Matrix3Identity(InertiaTensor);

	// object data
	Name = "";
	Description = "";
	Inventary.clear();

	// script
	ScriptFile = "";
	ScriptVar.clear();
}



void DataModel::Reset()
{

	filename = "";
	for (int i=0;i<4;i++){
		Skin[i].Vertex.clear();
		Skin[i].NormalModeAll = NormalModeAngular;
		for (int j=0;j<Material.num;j++)
			Skin[i].Sub[j].Triangle.clear();
		Skin[i].Sub.resize(1);
	}
	Surface.clear();
	Vertex.clear();
	Ball.clear();
	Poly.clear();
	Fx.clear();
	Material.resize(1);
	Material[0].reset();
	NormalModeAll = NormalModeAngular;

	CurrentMaterial = 0;
	CurrentTextureLevel = 0;

	SkinVertMat = SkinVertTL = -1;

	// skeleton
	Bone.clear();

	Move.clear();
	move = EmptyMove;
	CurrentMove = -1;
	CurrentFrame = 0;
	TimeScale = 1;
	TimeParam = 0;
	Playing = false;
	PlayLoop = true;


	for (int i=0;i<4;i++){
		Skin[i].Sub.resize(1);
		Skin[i].Sub[0].NumTextures = 1;
	}

	Radius = 42;

	meta_data.Reset();

	ResetHistory();
	Notify("Change");
}

void DataModel::DebugShow()
{
	msg_write("------------");
	msg_write(Vertex.num);
	msg_write(Surface.num);
	foreach(ModelSurface &s, Surface){
		msg_write(s.Polygon.num);
		s.TestSanity("Model.DebugShow");
	}
}

bool DataModel::TestSanity(const string &loc)
{
	foreach(ModelSurface &s, Surface){
		if (!s.TestSanity(loc))
			return false;
	}
	return true;
}



int get_normal_index(vector &n)
{
	int nxy, nz;
	if ((n.x == 0) && (n.y == 0)){
		nxy = 0;
		nz = (n.z < 0) ? 255 : 0;
	}else{
		nxy = (int)(atan2(n.y, n.x) / pi / 2 * 255.0f) & 255;
		nz = (int)(acos(n.z) / pi * 255.0f) & 255;
	}
	return nxy + 256 * nz;
}

vector get_normal_by_index(int index)
{
	float wz = (float)(index >> 8) * pi / 255.0f;
	float wxy = (float)(index & 255) * 2 * pi / 255.0f;
	float swz = sin(wz);
	if (swz < 0)
		swz = - swz;
	float cwz = cos(wz);
	return vector( cos(wxy) * swz, sin(wxy) * swz, cwz);
}




bool DataModel::Load(const string & _filename, bool deep)
{
	msg_db_r("Model::LoadFromFile",1);
	//if (allow_load)
	Reset();
	bool error=false;
	int ffv;

	Array<vector> skin_vert;

	filename = _filename;
	if (this == mode_model->data)
		ed->MakeDirs(filename);
	//msg_write(dir);
	//msg_write(filename);
	CFile *f=new CFile();
	if (!f->Open(filename)){
		delete(f);
		ed->SetMessage(_("Datei ist nicht in der Stimmung, ge&offnet zu werden"));
		msg_db_l(1);
		return false;
	}
	file_time = f->GetDateModification().time;

	ffv=f->ReadFileFormatVersion();

	if (ffv<0){
		ed->ErrorBox(_("Datei-Format unlesbar!"));
		msg_db_l(1);
		error=true;

	}else if (ffv==10){ // old format

		// Materials
		Material.resize(f->ReadIntC());
		for (int i=0;i<Material.num;i++){
			Material[i].MaterialFile = f->ReadStr();
			Material[i].UserColor = f->ReadBool();
			if (Material[i].UserColor){
				read_color_argb(f, Material[i].Ambient);
				read_color_argb(f, Material[i].Diffuse);
				read_color_argb(f, Material[i].Specular);
				read_color_argb(f, Material[i].Emission);
				Material[i].Shininess = (float)f->ReadInt();
			}
			Material[i].TransparencyMode = f->ReadInt();
			Material[i].UserTransparency = (Material[i].TransparencyMode != TransparencyModeDefault);
			Material[i].AlphaSource = f->ReadInt();
			Material[i].AlphaDestination = f->ReadInt();
			Material[i].AlphaFactor = (float)f->ReadInt() * 0.01f;
			Material[i].AlphaZBuffer = f->ReadBool();
			Material[i].NumTextures = f->ReadInt();
			for (int t=0;t<Material[i].NumTextures;t++)
				Material[i].TextureFile[t] = f->ReadStr();
		}
		// create subs...
		for (int k=0;k<4;k++){
			Skin[k].Sub.resize(Material.num);
			for (int j=0;j<Material.num;j++)
				Skin[k].Sub[j].NumTextures = 1;
		}

	// Physical Skin

		// vertices
		Skin[0].Vertex.resize(f->ReadIntC());
		for (int j=0;j<Skin[0].Vertex.num;j++){
			Skin[0].Vertex[j].BoneIndex = f->ReadInt();
			if (Skin[0].Vertex[j].BoneIndex < 0)
				Skin[0].Vertex[j].BoneIndex = 0;
			f->ReadVector(&Skin[0].Vertex[j].pos);
		}

		// triangles
		Skin[0].Sub[0].Triangle.resize(f->ReadInt());
		for (int j=0;j<Skin[0].Sub[0].Triangle.num;j++){
			Skin[0].Sub[0].Triangle[j].NormalDirty = true;
			for (int k=0;k<3;k++)
				Skin[0].Sub[0].Triangle[j].Vertex[k] = f->ReadInt();
		}

		// balls
		Ball.resize(f->ReadInt());
		for (int j=0;j<Ball.num;j++){
			Ball[j].Index = f->ReadInt();
			Ball[j].Radius = f->ReadFloat();
		}

		// polys
		Poly.resize(f->ReadInt());
		for (int j=0;j<Poly.num;j++){
			Poly[j].NumFaces = f->ReadInt();
			for (int k=0;k<Poly[j].NumFaces;k++){
				Poly[j].Face[k].NumVertices = f->ReadInt();
				for (int l=0;l<Poly[j].Face[k].NumVertices;l++)
					Poly[j].Face[k].Index[l] = f->ReadInt();
			}
		}

	// Skin[i]
		for (int i=1;i<4;i++){
			Skin[i].NormalModeAll = f->ReadIntC();
			bool pre_normals = (Skin[i].NormalModeAll & NormalModePre) > 0;
			Skin[i].NormalModeAll -= (Skin[i].NormalModeAll & NormalModePre);

			// vertices
			Skin[i].Vertex.resize(f->ReadInt());
			for (int j=0;j<Skin[i].Vertex.num;j++){
				Skin[i].Vertex[j].BoneIndex = f->ReadInt();
				if (Skin[i].Vertex[j].BoneIndex < 0)
					Skin[i].Vertex[j].BoneIndex = 0;
				f->ReadVector(&Skin[i].Vertex[j].pos);
				if (Skin[i].NormalModeAll == NormalModePerVertex)
					Skin[i].Vertex[j].NormalMode = f->ReadByte();
				else
					Skin[i].Vertex[j].NormalMode = Skin[i].NormalModeAll;
				Skin[i].Vertex[j].NormalDirty = true;
			}

			// skin vertices
			skin_vert.resize(f->ReadInt());
			for (int j=0;j<skin_vert.num;j++){
				skin_vert[j].x = f->ReadFloat();
				skin_vert[j].y = f->ReadFloat();
			}



			// triangles (subs)
			int num_trias = f->ReadInt();
			for (int t=0;t<Material.num;t++)
				Skin[i].Sub[t].Triangle.resize(f->ReadInt());
			for (int t=0;t<Material.num;t++)
				for (int j=0;j<Skin[i].Sub[t].Triangle.num;j++)
					for (int k=0;k<3;k++){
						Skin[i].Sub[t].Triangle[j].Vertex[k] = f->ReadInt();
						int svi = f->ReadInt();
						Skin[i].Sub[t].Triangle[j].SkinVertex[0][k] = skin_vert[svi];
						Skin[i].Sub[t].Triangle[j].NormalIndex[k] = (int)f->ReadByte();
						Skin[i].Sub[t].Triangle[j].NormalDirty = true;
					}
		}

	// Skeleton
		Bone.resize(f->ReadIntC());
		for (int i=0;i<Bone.num;i++){
			f->ReadVector(&Bone[i].DeltaPos);
			Bone[i].Parent = f->ReadInt();
			if (Bone[i].Parent > 32000)
				Bone[i].Parent = -1;
			Bone[i].ModelFile = f->ReadStr();
			if (deep)
				Bone[i].model = LoadModel(Bone[i].ModelFile);
			Bone[i].ConstPos = false;
			Bone[i].is_selected = Bone[i].m_old = false;
		}

	// Animations
		int num_anims = f->ReadIntC();
		for (int i=0;i<num_anims;i++){
			int anim_index = f->ReadInt();
			Move.resize(anim_index + 1);
			ModelMove *m = &Move[anim_index];
			m->Name = f->ReadStr();
			m->Type = f->ReadInt();
			m->Frame.resize(f->ReadInt());
			m->FramesPerSecConst = f->ReadFloat();
			m->FramesPerSecFactor = f->ReadFloat();

			// vertex animation
			if (m->Type == MoveTypeVertex){
				for (int fr=0;fr<m->Frame.num;fr++){
					for (int s=0;s<4;s++){
						m->Frame[fr].Skin[s].DPos.resize(Skin[s].Vertex.num);
						int num_vertices = f->ReadInt();
						for (int j=0;j<num_vertices;j++){
							int vertex_index = f->ReadInt();
							f->ReadVector(&m->Frame[fr].Skin[s].DPos[vertex_index]);
						}
					}
				}
			}else if (m->Type == MoveTypeSkeletal){
				Array<bool> VarDeltaPos;
				VarDeltaPos.resize(Bone.num);
				for (int j=0;j<Bone.num;j++)
					VarDeltaPos[j] = f->ReadBool();
				m->InterpolatedQuadratic = f->ReadBool();
				m->InterpolatedLoop = f->ReadBool();
				for (int fr=0;fr<m->Frame.num;fr++){
					m->Frame[fr].SkelDPos.resize(Bone.num);
					m->Frame[fr].SkelAng.resize(Bone.num);
					for (int j=0;j<Bone.num;j++){
						f->ReadVector(&m->Frame[fr].SkelAng[j]);
						if (VarDeltaPos[j])
							f->ReadVector(&m->Frame[fr].SkelDPos[j]);
					}
				}
			}
		}
		// Effects
		Fx.resize(f->ReadIntC());
		if (Fx.num>10000)
			Fx.clear();
		for (int i=0;i<Fx.num;i++){
			string fxkind = f->ReadStr();
			Fx[i].Kind = -1;
			if (fxkind == "Script"){
				Fx[i].Kind = FXKindScript;
				Fx[i].Vertex = f->ReadInt();
				Fx[i].File = f->ReadStr();
				f->ReadStr();
			}
			if (fxkind == "Light"){
				Fx[i].Kind = FXKindLight;
				Fx[i].Vertex = f->ReadInt();
				Fx[i].Size = (float)f->ReadInt();
				for (int j=0;j<3;j++)
					read_color_argb(f,Fx[i].Colors[j]);
			}
			if (fxkind == "Sound"){
				Fx[i].Kind = FXKindSound;
				Fx[i].Vertex = f->ReadInt();
				Fx[i].Size = (float)f->ReadInt();
				Fx[i].Speed = (float)f->ReadInt() * 0.01f;
				Fx[i].File = f->ReadStr();
			}
			if (fxkind == "ForceField"){
				Fx[i].Kind = FXKindForceField;
				Fx[i].Vertex = f->ReadInt();
				Fx[i].Size = (float)f->ReadInt();
				Fx[i].Intensity = (float)f->ReadInt();
				Fx[i].InvQuad = f->ReadBool();
			}
			if (Fx[i].Kind<0)
				msg_error("unknown effekt: " + fxkind);
		}
		// LOD-Distances
		meta_data.DetailDist[0]=f->ReadFloatC();
		meta_data.DetailDist[1]=f->ReadFloat();
		meta_data.DetailDist[2]=f->ReadFloat();
		meta_data.AutoGenerateDists=f->ReadBool();
		meta_data.DetailFactor[1]=f->ReadByte();
		meta_data.DetailFactor[2]=f->ReadByte();
		meta_data.AutoGenerateSkin[1]=f->ReadBool();
		meta_data.AutoGenerateSkin[2]=f->ReadBool();
		// Physics
		meta_data.AutoGenerateTensor = f->ReadBoolC();
		for (int i=0;i<9;i++)
			meta_data.InertiaTensor.e[i] = f->ReadFloat();
		// BG Textures
		/*if (strcmp(f->ReadStr(),"#")!=0){
			for (int i=0;i<4;i++){
				char sss[512];
				strcpy(sss,f->ReadStr());
				if (strlen(sss)>0){
					strcpy(BgTextureFile[i],sss);
					if (allow_load)
						BgTexture[i]=NixLoadTexture(sss);
					BgTextureA[i].x=f->ReadFloat();
					BgTextureA[i].y=f->ReadFloat();
					BgTextureA[i].z=f->ReadFloat();
					BgTextureB[i].x=f->ReadFloat();
					BgTextureB[i].y=f->ReadFloat();
					BgTextureB[i].z=f->ReadFloat();
				}
			}
		}*/

		// correction
		/*skin=&Skin[1];
		SetNormalMode(NormalModeAngular,true);
		skin=&Skin[2];
		SetNormalMode(NormalModeAngular,true);
		skin=&Skin[3];
		SetNormalMode(NormalModeAngular,true);
		AlphaZBuffer=(TransparencyMode!=TransparencyModeFunctions)&&(TransparencyMode!=TransparencyModeFactor);*/


	}else if (ffv==11){ // new format


		// General
		vector tv;
		f->ReadComment();
		// bounding box
		f->ReadVector(&tv);
		f->ReadVector(&tv);
		// skins
		f->ReadInt();
		// reserved
		f->ReadInt();
		f->ReadInt();
		f->ReadInt();
		//

		// Materials
		Material.resize(f->ReadIntC());
		for (int i=0;i<Material.num;i++){
			Material[i].MaterialFile = f->ReadStr();
			Material[i].UserColor = f->ReadBool();
			read_color_argb(f, Material[i].Ambient);
			read_color_argb(f, Material[i].Diffuse);
			read_color_argb(f, Material[i].Specular);
			read_color_argb(f, Material[i].Emission);
			Material[i].Shininess = (float)f->ReadInt();
			Material[i].TransparencyMode = f->ReadInt();
			Material[i].UserTransparency = (Material[i].TransparencyMode != TransparencyModeDefault);
			Material[i].AlphaSource = f->ReadInt();
			Material[i].AlphaDestination = f->ReadInt();
			Material[i].AlphaFactor = (float)f->ReadInt() * 0.01f;
			Material[i].AlphaZBuffer = f->ReadBool();
			Material[i].NumTextures = f->ReadInt();
			for (int t=0;t<Material[i].NumTextures;t++)
				Material[i].TextureFile[t] = f->ReadStr();
		}
		// create subs...
		for (int k=0;k<4;k++){
			Skin[k].Sub.resize(Material.num);
			for (int j=0;j<Material.num;j++)
				Skin[k].Sub[j].NumTextures = Material[j].NumTextures;
		}

	// Physical Skin

		// vertices
		Skin[0].Vertex.resize(f->ReadIntC());
		for (int j=0;j<Skin[0].Vertex.num;j++)
			Skin[0].Vertex[j].BoneIndex = f->ReadInt();
		for (int j=0;j<Skin[0].Vertex.num;j++)
			f->ReadVector(&Skin[0].Vertex[j].pos);

		// triangles
		f->ReadInt();

		// balls
		Ball.resize(f->ReadInt());
		for (int j=0;j<Ball.num;j++){
			Ball[j].Index = f->ReadInt();
			Ball[j].Radius = f->ReadFloat();
		}

		// polys
		Poly.resize(f->ReadInt());
		for (int j=0;j<Poly.num;j++){
			Poly[j].NumFaces = f->ReadInt();
			for (int k=0;k<Poly[j].NumFaces;k++){
				Poly[j].Face[k].NumVertices = f->ReadInt();
				for (int l=0;l<Poly[j].Face[k].NumVertices;l++)
					Poly[j].Face[k].Index[l] = f->ReadInt();
				f->ReadFloat();
				f->ReadFloat();
				f->ReadFloat();
				f->ReadFloat();
			}
			Poly[j].NumSVertices = f->ReadInt();
			for (int k=0;k<Poly[j].NumSVertices;k++)
				f->ReadInt();
			Poly[j].NumEdges = f->ReadInt();
			for (int k=0;k<Poly[j].NumEdges*2;k++)
				f->ReadInt();
			// topology
			for (int k=0;k<Poly[j].NumFaces*Poly[j].NumFaces;k++)
				f->ReadInt();
			for (int k=0;k<Poly[j].NumEdges*Poly[j].NumFaces;k++)
				f->ReadBool();
		}

	// Skin[i]
		for (int i=1;i<4;i++){

			// vertices
			Skin[i].Vertex.resize(f->ReadIntC());
			for (int j=0;j<Skin[i].Vertex.num;j++)
				f->ReadVector(&Skin[i].Vertex[j].pos);
			for (int j=0;j<Skin[i].Vertex.num;j++)
				Skin[i].Vertex[j].BoneIndex = f->ReadInt();
			for (int j=0;j<Skin[i].Vertex.num;j++)
				Skin[i].Vertex[j].NormalDirty = false;//true;

			// skin vertices
			skin_vert.resize(f->ReadInt());
			for (int j=0;j<skin_vert.num;j++){
				skin_vert[j].x = f->ReadFloat();
				skin_vert[j].y = f->ReadFloat();
			}



			// triangles (subs)
			for (int m=0;m<Material.num;m++){
				Skin[i].Sub[m].Triangle.resize(f->ReadInt());
				// vertex
				for (int j=0;j<Skin[i].Sub[m].Triangle.num;j++)
					for (int k=0;k<3;k++)
						Skin[i].Sub[m].Triangle[j].Vertex[k] = f->ReadInt();
				// skin vertex
				for (int tl=0;tl<Material[m].NumTextures;tl++)
					for (int j=0;j<Skin[i].Sub[m].Triangle.num;j++)
						for (int k=0;k<3;k++){
							int svi = f->ReadInt();
							Skin[i].Sub[m].Triangle[j].SkinVertex[tl][k] = skin_vert[svi];
						}
				// normals
				for (int j=0;j<Skin[i].Sub[m].Triangle.num;j++){
					for (int k=0;k<3;k++){
						Skin[i].Sub[m].Triangle[j].NormalIndex[k] = (int)(unsigned short)f->ReadWord();
						Skin[i].Sub[m].Triangle[j].Normal[k] = get_normal_by_index(Skin[i].Sub[m].Triangle[j].NormalIndex[k]);
					}
					Skin[i].Sub[m].Triangle[j].NormalDirty = false;
				}
				f->ReadInt();
			}
			f->ReadInt();
		}

	// Skeleton
		Bone.resize(f->ReadIntC());
		for (int i=0;i<Bone.num;i++){
			f->ReadVector(&Bone[i].DeltaPos);
			Bone[i].Parent = f->ReadInt();
			Bone[i].ModelFile = f->ReadStr();
			if (deep)
				Bone[i].model = LoadModel(Bone[i].ModelFile);
			Bone[i].ConstPos = false;
			Bone[i].is_selected = Bone[i].m_old = false;
		}

	// Animations
		Move.resize(f->ReadIntC());
		int num_anims = f->ReadInt();
		f->ReadInt();
		f->ReadInt();
		for (int i=0;i<num_anims;i++){
			int anim_index = f->ReadInt();
			Move.resize(anim_index + 1);
			ModelMove *m = &Move[anim_index];
			m->Name = f->ReadStr();
			m->Type = f->ReadInt();
			m->Frame.resize(f->ReadInt());
			m->FramesPerSecConst = f->ReadFloat();
			m->FramesPerSecFactor = f->ReadFloat();

			// vertex animation
			if (m->Type == MoveTypeVertex){
				for (int fr=0;fr<m->Frame.num;fr++){
					for (int s=0;s<4;s++){
						m->Frame[fr].Skin[s].DPos.resize(Skin[s].Vertex.num);
						int num_vertices = f->ReadInt();
						for (int j=0;j<num_vertices;j++){
							int vertex_index = f->ReadInt();
							f->ReadVector(&m->Frame[fr].Skin[s].DPos[vertex_index]);
						}
					}
				}
			}else if (m->Type == MoveTypeSkeletal){
				Array<bool> VarDeltaPos;
				VarDeltaPos.resize(Bone.num);
				for (int j=0;j<Bone.num;j++)
					VarDeltaPos[j] = f->ReadBool();
				m->InterpolatedQuadratic = f->ReadBool();
				m->InterpolatedLoop = f->ReadBool();
				for (int fr=0;fr<m->Frame.num;fr++){
					m->Frame[fr].SkelDPos.resize(Bone.num);
					m->Frame[fr].SkelAng.resize(Bone.num);
					for (int j=0;j<Bone.num;j++){
						f->ReadVector(&m->Frame[fr].SkelAng[j]);
						if (VarDeltaPos[j])
							f->ReadVector(&m->Frame[fr].SkelDPos[j]);
					}
				}
			}
		}
		// Effects
		Fx.resize(f->ReadIntC());
		if (Fx.num>10000)
			Fx.clear();
		for (int i=0;i<Fx.num;i++){
			string fxkind = f->ReadStr();
			Fx[i].Kind=-1;
			if (fxkind == "Script"){
				Fx[i].Kind = FXKindScript;
				Fx[i].Vertex = f->ReadInt();
				Fx[i].File = f->ReadStr();
				f->ReadStr();
			}
			if (fxkind == "Light"){
				Fx[i].Kind = FXKindLight;
				Fx[i].Vertex = f->ReadInt();
				Fx[i].Size = (float)f->ReadInt();
				for (int j=0;j<3;j++)
					read_color_argb(f,Fx[i].Colors[j]);
			}
			if (fxkind == "Sound"){
				Fx[i].Kind = FXKindSound;
				Fx[i].Vertex = f->ReadInt();
				Fx[i].Size = (float)f->ReadInt();
				Fx[i].Speed = (float)f->ReadInt() * 0.01f;
				Fx[i].File = f->ReadStr();
			}
			if (fxkind == "ForceField"){
				Fx[i].Kind = FXKindForceField;
				Fx[i].Vertex = f->ReadInt();
				Fx[i].Size = (float)f->ReadInt();
				Fx[i].Intensity = (float)f->ReadInt();
				Fx[i].InvQuad = f->ReadBool();
			}
			if (Fx[i].Kind<0)
				msg_error("unknown effekt: " + fxkind);
		}

// properties
		// Physics
		meta_data.Mass = f->ReadFloatC();
		for (int i=0;i<9;i++)
			meta_data.InertiaTensor.e[i] = f->ReadFloat();
		meta_data.ActivePhysics = f->ReadBool();
		meta_data.PassivePhysics = f->ReadBool();
		Radius = f->ReadFloat();

		// LOD-Distances
		meta_data.DetailDist[0] = f->ReadFloatC();
		meta_data.DetailDist[1] = f->ReadFloat();
		meta_data.DetailDist[2] = f->ReadFloat();

// object data
		// Object Data
		meta_data.Name = f->ReadStrC();
		meta_data.Description = f->ReadStr();

		// Inventary
		meta_data.Inventary.resize(f->ReadIntC());
		for (int i=0;i<meta_data.Inventary.num;i++){
			meta_data.Inventary[i] = f->ReadStr();
			f->ReadInt();
		}

		// Script
		meta_data.ScriptFile = f->ReadStrC();
		meta_data.ScriptVar.resize(f->ReadInt());
		for (int i=0;i<meta_data.ScriptVar.num;i++)
			meta_data.ScriptVar[i] = f->ReadFloat();


// additional data for editing
		// Editor
		meta_data.AutoGenerateTensor = f->ReadBoolC();
		meta_data.AutoGenerateDists = f->ReadBool();
		meta_data.AutoGenerateSkin[1] = f->ReadBool();
		meta_data.AutoGenerateSkin[2] = f->ReadBool();
		meta_data.DetailFactor[1] = f->ReadInt();
		meta_data.DetailFactor[2] = f->ReadInt();
		// Normals
		f->ReadComment();
		for (int i=1;i<4;i++){
			ModelSkin *s = &Skin[i];
			s->NormalModeAll = f->ReadInt();
			if (s->NormalModeAll == NormalModePerVertex){
				foreach(ModelVertex &v, s->Vertex)
					v.NormalMode = f->ReadInt();
			}else{
				foreach(ModelVertex &v, s->Vertex)
					v.NormalMode = s->NormalModeAll;
			}
		   }

		// Polygons
		if (f->ReadStr() == "// Polygons"){
			NormalModeAll = Skin[1].NormalModeAll;
			foreachi(ModelVertex &v, Skin[1].Vertex, i)
				AddVertex(v.pos, v.BoneIndex, v.NormalMode);
			int ns = f->ReadInt();
			for (int i=0;i<ns;i++){
				ModelSurface s;
				int nv = f->ReadInt();
				for (int j=0;j<nv;j++){
					ModelPolygon t;
					t.is_selected = false;
					t.TriangulationDirty = true;
					int n = f->ReadInt();
					t.Material = f->ReadInt();
					t.Side.resize(n);
					for (int k=0;k<n;k++){
						t.Side[k].Vertex = f->ReadInt();
						for (int l=0;l<Material[t.Material].NumTextures;l++){
							t.Side[k].SkinVertex[l].x = f->ReadFloat();
							t.Side[k].SkinVertex[l].y = f->ReadFloat();
						}
					}
					t.NormalDirty = true;
					s.Polygon.add(t);
				}
				s.IsPhysical = f->ReadBool();
				s.IsVisible = f->ReadBool();
				s.is_selected = false;
				f->ReadInt();
				s.model = this;
				Surface.add(s);
			}
			foreach(ModelSurface &s, Surface)
				s.BuildFromPolygons();
		}







	}else{
		ed->ErrorBox(format(_("Falsches Datei-Format der Datei '%s': %d (statt %d - %d)"), filename.c_str(), ffv, 10, 10));
		error=true;
	}

	f->Close();
	delete(f);








	if (deep){

		// import...
		if (Surface.num == 0)
			ImportFromTriangleSkin(1);

		foreach(ModelMove &m, Move)
			if (m.Type == MoveTypeVertex){
				foreach(ModelFrame &f, m.Frame)
					f.VertexDPos = f.Skin[1].DPos;
			}

		for (int i=0;i<Material.num;i++){
			Material[i].MakeConsistent();

			// test textures
			for (int t=0;t<Material[i].NumTextures;t++){
				if ((Material[i].Texture[t] < 0) && (Material[i].TextureFile[t].num > 0))
					ed->SetMessage(format(_("Textur-Datei nicht ladbar: %s"), Material[i].TextureFile[t].c_str()));
			}
		}



		// TODO -> mode...
		/*if (this == mode_model->data){
			ed->SetTitle(filename);
			ResetView();
		}*/
	}


	//OptimizeView();
	ResetHistory();

	if (deep)
		UpdateNormals();
	msg_db_l(1);
	return !error;
}

void DataModel::ImportFromTriangleSkin(int index)
{
	Vertex.clear();
	Surface.clear();

	ModelSkin &s = Skin[index];
	NotifyBegin();
	NormalModeAll = s.NormalModeAll;
	foreachi(ModelVertex &v, s.Vertex, i){
		AddVertex(v.pos);
		Vertex[i].BoneIndex = v.BoneIndex;
	}
	for (int i=0;i<Material.num;i++){
		CurrentMaterial = i;
		foreach(ModelTriangle &t, s.Sub[i].Triangle){
			if ((t.Vertex[0] == t.Vertex[1]) || (t.Vertex[1] == t.Vertex[2]) || (t.Vertex[2] == t.Vertex[0]))
				continue;
			Array<int> v;
			for (int k=0;k<3;k++)
				v.add(t.Vertex[k]);
			Array<vector> sv;
			for (int tl=0;tl<Material[i].NumTextures;tl++)
				for (int k=0;k<3;k++)
					sv.add(t.SkinVertex[tl][k]);
			AddPolygonWithSkin(v, sv);
		}
	}
	ClearSelection();
	NotifyEnd();
	action_manager->Reset();
}

void DataModel::ExportToTriangleSkin(int index)
{
	ModelSkin &sk = Skin[index];
	sk.NormalModeAll = NormalModeAll;
	sk.Vertex = Vertex;
	sk.Sub.clear();
	sk.Sub.resize(Material.num);
	foreach(ModelSurface &s, Surface)
		foreach(ModelPolygon &t, s.Polygon){
			if (t.TriangulationDirty)
				t.UpdateTriangulation(this);
			for (int i=0;i<t.Side.num-2;i++){
				ModelTriangle tt;
				for (int k=0;k<3;k++){
					tt.Vertex[k] = t.Side[t.Side[i].Triangulation[k]].Vertex;
					tt.Normal[k] = t.Side[t.Side[i].Triangulation[k]].Normal;
					for (int l=0;l<MATERIAL_MAX_TEXTURES;l++)
						tt.SkinVertex[l][k] = t.Side[t.Side[i].Triangulation[k]].SkinVertex[l];
				}
				sk.Sub[t.Material].Triangle.add(tt);
			}
		}
	foreachi(ModelMaterial &m, Material, i)
		sk.Sub[i].NumTextures = m.NumTextures;
}


void DataModel::GetBoundingBox(vector &min, vector &max)
{
	// bounding box (visual skin[1])
	min = max = v_0;
	for (int i=0;i<Skin[1].Vertex.num;i++){
		min._min(Skin[1].Vertex[i].pos);
		max._max(Skin[1].Vertex[i].pos);
	}
	// (physical skin)
	for (int i=0;i<Skin[0].Vertex.num;i++){
		min._min(Skin[0].Vertex[i].pos);
		max._max(Skin[0].Vertex[i].pos);
	}
	for (int i=0;i<Ball.num;i++){
		min._min(Skin[0].Vertex[Ball[i].Index].pos - vector(1,1,1) * Ball[i].Radius);
		max._max(Skin[0].Vertex[Ball[i].Index].pos + vector(1,1,1) * Ball[i].Radius);
	}
}


bool DataModel::Save(const string & _filename)
{
	msg_db_r("DataModel.Save",1);

	/*if (AutoGenerateSkin[1])
		CreateSkin(&Skin[1],&Skin[2],(float)DetailFactor[1]*0.01f);

	if (AutoGenerateSkin[2])
		CreateSkin(&Skin[2],&Skin[3],(float)DetailFactor[2]/(float)DetailFactor[1]);*/

	if (meta_data.AutoGenerateDists)
		GenerateDetailDists(meta_data.DetailDist);

	if (meta_data.AutoGenerateTensor)
		meta_data.InertiaTensor = GenerateInertiaTensor(meta_data.Mass);



#ifdef FORCE_UPDATE_NORMALS
	for (int d=1;d<4;d++)
		for (int j=0;j<Skin[d].NumVertices;j++)
			Skin[d].Vertex[j].NormalDirty = true;
#endif
	UpdateNormals();

	// export...
	ExportToTriangleSkin(1);
	for (int d=1;d<4;d++){
		if (Skin[d].Sub.num != Material.num){
			Skin[d].Sub.resize(Material.num);
		}
	}



//	PrecreatePhysicalData();

	GetBoundingBox(Min, Max);
	GetDiameter();
	Radius = GetDiameter() * 0.6f;


	// so the materials don't get mixed up
//	RemoveUnusedData();

	filename = _filename;
	ed->MakeDirs(filename);

	CFile *f = CreateFile(filename);
	f->WriteFileFormatVersion(false, 11);//FFVBinary, 11);
	f->FloatDecimals = 5;

// general
	f->WriteComment("// General");
	f->WriteVector(&Min);
	f->WriteVector(&Max);
	f->WriteInt(3); // skins...
	f->WriteInt(0); // reserved
	f->WriteInt(0);
	f->WriteInt(0);

// materials
	f->WriteComment("// Materials");
	f->WriteInt(Material.num);
	foreach(ModelMaterial &m, Material){
		f->WriteStr(m.MaterialFile);
		f->WriteBool(m.UserColor);
		write_color_argb(f, m.Ambient);
		write_color_argb(f, m.Diffuse);
		write_color_argb(f, m.Specular);
		write_color_argb(f, m.Emission);
		f->WriteInt(m.Shininess);
		f->WriteInt(m.UserTransparency ? m.TransparencyMode : TransparencyModeDefault);
		f->WriteInt(m.AlphaSource);
		f->WriteInt(m.AlphaDestination);
		f->WriteInt(m.AlphaFactor * 100.0f);
		f->WriteBool(m.AlphaZBuffer);
		f->WriteInt(m.NumTextures);
		for (int t=0;t<m.NumTextures;t++)
			f->WriteStr(m.TextureFile[t]);
	}

// physical skin
	f->WriteComment("// Physical Skin");

	// vertices
	f->WriteInt(Skin[0].Vertex.num);
	for (int j=0;j<Skin[0].Vertex.num;j++)
		f->WriteInt(Skin[0].Vertex[j].BoneIndex);
	for (int j=0;j<Skin[0].Vertex.num;j++)
		f->WriteVector(&Skin[0].Vertex[j].pos);

	// triangles
	f->WriteInt(0);
	/*for (int j=0;j<Skin[0].NumTriangles;j++)
		for (int k=0;k<3;k++)
			f->WriteInt(Skin[0].Triangle[j].Index[k]);*/

	// balls
	f->WriteInt(Ball.num);
	for (int j=0;j<Ball.num;j++){
		f->WriteInt(Ball[j].Index);
		f->WriteFloat(Ball[j].Radius);
	}

	f->WriteInt(Poly.num);
	for (int j=0;j<Poly.num;j++){
		f->WriteInt(Poly[j].NumFaces);
		for (int k=0;k<Poly[j].NumFaces;k++){
			f->WriteInt(Poly[j].Face[k].NumVertices);
			for (int l=0;l<Poly[j].Face[k].NumVertices;l++)
				f->WriteInt(Poly[j].Face[k].Index[l]);
			f->WriteFloat(Poly[j].Face[k].Plane.n.x);
			f->WriteFloat(Poly[j].Face[k].Plane.n.y);
			f->WriteFloat(Poly[j].Face[k].Plane.n.z);
			f->WriteFloat(Poly[j].Face[k].Plane.d);
		}
		f->WriteInt(Poly[j].NumSVertices);
		for (int k=0;k<Poly[j].NumSVertices;k++)
			f->WriteInt(Poly[j].SIndex[k]);
		f->WriteInt(Poly[j].NumEdges);
		for (int k=0;k<Poly[j].NumEdges;k++){
			f->WriteInt(Poly[j].EdgeIndex[k*2 + 0]);
			f->WriteInt(Poly[j].EdgeIndex[k*2 + 1]);
		}
		// topology
		for (int k=0;k<Poly[j].NumFaces;k++)
			for (int l=0;l<Poly[j].NumFaces;l++)
				f->WriteInt(Poly[j].FacesJoiningEdge[k * Poly[j].NumFaces + l]);
		for (int k=0;k<Poly[j].NumEdges;k++)
			for (int l=0;l<Poly[j].NumFaces;l++)
			    f->WriteBool(Poly[j].EdgeOnFace[k * Poly[j].NumFaces + l]);
	}

// skin
	for (int i=1;i<4;i++){
		ModelSkin *s = &Skin[i];
		f->WriteComment(format("// Skin[%d]",i));

		// verices
		f->WriteInt(s->Vertex.num);
		foreach(ModelVertex &v, s->Vertex)
			f->WriteVector(&v.pos);
		foreach(ModelVertex &v, s->Vertex)
			f->WriteInt(v.BoneIndex);

	    // skin vertices
		int num_skin_v = 0;
		for (int m=0;m<Material.num;m++)
			num_skin_v += s->Sub[m].Triangle.num * s->Sub[m].NumTextures * 3;
		f->WriteInt(num_skin_v);
		for (int m=0;m<Material.num;m++)
			for (int tl=0;tl<s->Sub[m].NumTextures;tl++)
		    	for (int j=0;j<s->Sub[m].Triangle.num;j++)
					for (int k=0;k<3;k++){
						f->WriteFloat(s->Sub[m].Triangle[j].SkinVertex[tl][k].x);
						f->WriteFloat(s->Sub[m].Triangle[j].SkinVertex[tl][k].y);
					}


		// sub skins
		int svi = 0;
		for (int m=0;m<Material.num;m++){
			ModelSubSkin *sub = &s->Sub[m];

			// triangles
			f->WriteInt(sub->Triangle.num);

			// vertex index
	    	for (int j=0;j<sub->Triangle.num;j++)
				for (int k=0;k<3;k++)
					f->WriteInt(sub->Triangle[j].Vertex[k]);

			// skin index
			for (int tl=0;tl<sub->NumTextures;tl++)
		    	for (int j=0;j<sub->Triangle.num;j++)
					for (int k=0;k<3;k++)
						f->WriteInt(svi ++);

			// normal
	    	for (int j=0;j<sub->Triangle.num;j++)
				for (int k=0;k<3;k++){
					sub->Triangle[j].NormalIndex[k] = get_normal_index(sub->Triangle[j].Normal[k]);
					f->WriteWord(sub->Triangle[j].NormalIndex[k]);
				}
			f->WriteInt(0);
		}

		f->WriteInt(0);
	}

// skeleton
	f->WriteComment("// Skeleton");
	f->WriteInt(Bone.num);
	for (int i=0;i<Bone.num;i++){
		f->WriteVector(&Bone[i].DeltaPos);
		f->WriteInt(Bone[i].Parent);
		f->WriteStr(Bone[i].ModelFile);
	}

// animations
	f->WriteComment("// Animations");
	if ((Move.num == 1) && (Move[0].Frame.num == 0)){
		f->WriteInt(0);
	}else
		f->WriteInt(Move.num);
	int n_moves = 0;
	int n_frames_vert = 0;
	int n_frames_skel = 0;
	for (int i=0;i<Move.num;i++)
		if (Move[i].Frame.num > 0){
			n_moves ++;
			if (Move[i].Type == MoveTypeVertex)	n_frames_vert += Move[i].Frame.num;
			if (Move[i].Type == MoveTypeSkeletal)	n_frames_skel += Move[i].Frame.num;
		}
	f->WriteInt(n_moves);
	f->WriteInt(n_frames_vert);
	f->WriteInt(n_frames_skel);
	for (int i=0;i<Move.num;i++)
		if (Move[i].Frame.num > 0){
			ModelMove *m = &Move[i];
			f->WriteInt(i);
			f->WriteStr(m->Name);
			f->WriteInt(m->Type);
			f->WriteInt(m->Frame.num);
			f->WriteFloat(m->FramesPerSecConst);
			f->WriteFloat(m->FramesPerSecFactor);

			// vertex animation
			if (m->Type == MoveTypeVertex){
				for (int fr=0;fr<m->Frame.num;fr++){
					for (int s=0;s<4;s++){
						// compress (only write != 0)
						int num_vertices = 0;
						for (int j=0;j<Skin[s].Vertex.num;j++)
							if (m->Frame[fr].Skin[i].DPos[j] != v_0)
								num_vertices ++;
						f->WriteInt(num_vertices);
						for (int j=0;j<Skin[s].Vertex.num;j++)
							if (m->Frame[fr].Skin[i].DPos[j] != v_0){
								f->WriteInt(j);
								f->WriteVector(&m->Frame[fr].Skin[i].DPos[j]);
							}
					}
				}
			// skeletal animation
			}else if (m->Type == MoveTypeSkeletal){
				for (int j=0;j<Bone.num;j++)
					f->WriteBool((Bone[j].Parent < 0));
				f->WriteBool(m->InterpolatedQuadratic);
				f->WriteBool(m->InterpolatedLoop);
				for (int fr=0;fr<m->Frame.num;fr++)
					for (int j=0;j<Bone.num;j++){
						f->WriteVector(&m->Frame[fr].SkelAng[j]);
						if (Bone[j].Parent < 0)
							f->WriteVector(&m->Frame[fr].SkelDPos[j]);
					}
			}
		}

// effects
	f->WriteComment("// Effects");
	f->WriteInt(Fx.num);
	for (int i=0;i<Fx.num;i++){
		if (Fx[i].Kind==FXKindScript){
			f->WriteStr("Script");
			f->WriteInt(Fx[i].Vertex);
			f->WriteStr(Fx[i].File);
			f->WriteStr("");
		}else if (Fx[i].Kind==FXKindLight){
			f->WriteStr("Light");
			f->WriteInt(Fx[i].Vertex);
			f->WriteInt((int)Fx[i].Size);
			for (int nc=0;nc<3;nc++)
				write_color_argb(f, Fx[i].Colors[nc]);
		}else if (Fx[i].Kind==FXKindSound){
			f->WriteStr("Sound");
			f->WriteInt(Fx[i].Vertex);
			f->WriteInt((int)Fx[i].Size);
			f->WriteInt((int)(Fx[i].Speed * 100.0f));
			f->WriteStr(Fx[i].File);
		}else if (Fx[i].Kind==FXKindForceField){
			f->WriteStr("ForceField");
			f->WriteInt(Fx[i].Vertex);
			f->WriteInt((int)Fx[i].Size);
			f->WriteInt((int)Fx[i].Intensity);
			f->WriteBool(Fx[i].InvQuad);
		}
	}

// properties
	f->WriteComment("// Physics");
	f->WriteFloat(meta_data.Mass);
	for (int i=0;i<9;i++)
		f->WriteFloat(meta_data.InertiaTensor.e[i]);
	f->WriteBool(meta_data.ActivePhysics);
	f->WriteBool(meta_data.PassivePhysics);
	f->WriteFloat(Radius);

	f->WriteComment("// LOD-Distances");
	f->WriteFloat(meta_data.DetailDist[0]);
	f->WriteFloat(meta_data.DetailDist[1]);
	f->WriteFloat(meta_data.DetailDist[2]);

// object data
	f->WriteComment("// Object Data");
	f->WriteStr(meta_data.Name);
	f->WriteStr(meta_data.Description);

	// inventary
	f->WriteComment("// Inventary");
	f->WriteInt(meta_data.Inventary.num);
	for (int i=0;i<meta_data.Inventary.num;i++){
	    f->WriteStr(meta_data.Inventary[i]);
		f->WriteInt(1);
	}

	// script
	f->WriteComment("// Script");
	f->WriteStr(meta_data.ScriptFile);
	f->WriteInt(meta_data.ScriptVar.num);
	for (int i=0;i<meta_data.ScriptVar.num;i++)
	    f->WriteFloat(meta_data.ScriptVar[i]);

// additional data for editing
	f->WriteComment("// Editor");
	f->WriteBool(meta_data.AutoGenerateTensor);
	f->WriteBool(meta_data.AutoGenerateDists);
	f->WriteBool(meta_data.AutoGenerateSkin[1]);
	f->WriteBool(meta_data.AutoGenerateSkin[2]);
	f->WriteInt(meta_data.DetailFactor[1]);
	f->WriteInt(meta_data.DetailFactor[2]);
	f->WriteComment("// Normals");
	for (int i=1;i<4;i++){
		ModelSkin *s = &Skin[i];
		f->WriteInt(s->NormalModeAll);
		if (s->NormalModeAll == NormalModePerVertex){
			foreach(ModelVertex &v, s->Vertex)
				f->WriteInt(v.NormalMode);
		}
	}
	f->WriteComment("// Polygons");
	f->WriteInt(Surface.num);
	foreach(ModelSurface &s, Surface){
		f->WriteInt(s.Polygon.num);
		foreach(ModelPolygon &t, s.Polygon){
			f->WriteInt(t.Side.num);
			f->WriteInt(t.Material);
			foreach(ModelPolygonSide &ss, t.Side){
				f->WriteInt(ss.Vertex);
				for (int l=0;l<Material[t.Material].NumTextures;l++){
					f->WriteFloat(ss.SkinVertex[l].x);
					f->WriteFloat(ss.SkinVertex[l].y);
				}
			}
		}
		f->WriteBool(s.IsPhysical);
		f->WriteBool(s.IsVisible);
		f->WriteInt(0);
	}

	f->WriteComment("#");
	FileClose(f);

	ed->SetMessage(_("Gespeichert!"));
	action_manager->MarkCurrentAsSave();
	msg_db_l(1);
	return true;
}

void DataModel::SetNormalsDirtyByVertices(const Array<int> &index)
{
	foreach(ModelSurface &s, Surface)
		foreach(ModelPolygon &t, s.Polygon)
			for (int k=0;k<t.Side.num;k++)
				if (!t.NormalDirty)
					for (int i=0;i<index.num;i++)
						if (t.Side[k].Vertex == index[i]){
							t.NormalDirty = true;
							break;
						}
}

void DataModel::SetAllNormalsDirty()
{
	foreach(ModelSurface &s, Surface)
		foreach(ModelPolygon &t, s.Polygon)
			t.NormalDirty = true;
}


void DataModel::UpdateNormals()
{
	foreach(ModelSurface &s, Surface)
		s.UpdateNormals();
}

ModelSurface *DataModel::AddSurface(int surf_no)
{
	ModelSurface s;
	s.model = this;
	s.view_stage = ed->multi_view_3d->view_stage;
	s.is_selected = true;
	s.IsClosed = false;
	s.IsVisible = true;
	s.IsPhysical = true;
	if (surf_no >= 0){
		Surface.insert(s, surf_no);
		return &Surface[surf_no];
	}else{
		Surface.add(s);
		return &Surface.back();
	}
}


void DataModel::AddVertex(const vector &pos, int bone_index, int normal_mode)
{	Execute(new ActionModelAddVertex(pos, bone_index, normal_mode));	}

void DataModel::ClearSelection()
{
	foreach(ModelVertex &v, Vertex)
		v.is_selected = false;
	foreach(ModelSurface &s, Surface){
		s.is_selected = false;
		foreach(ModelPolygon &t, s.Polygon)
			t.is_selected = false;
		foreach(ModelEdge &e, s.Edge)
			e.is_selected = false;
	}
	Notify("Selection");
}

void DataModel::SelectionFromSurfaces()
{
	foreach(ModelVertex &v, Vertex)
		v.is_selected = false;
	foreach(ModelSurface &s, Surface){
		foreach(int v, s.Vertex)
			Vertex[v].is_selected = s.is_selected;
		foreach(ModelPolygon &t, s.Polygon)
			t.is_selected = s.is_selected;
		foreach(ModelEdge &e, s.Edge)
			e.is_selected = s.is_selected;
	}
	Notify("Selection");
}

void DataModel::SelectionFromPolygons()
{
	foreach(ModelVertex &v, Vertex)
		v.is_selected = false;
	foreach(ModelSurface &s, Surface)
		foreach(ModelPolygon &t, s.Polygon)
			if (t.is_selected)
				for (int k=0;k<t.Side.num;k++)
					Vertex[t.Side[k].Vertex].is_selected = true;
	foreach(ModelSurface &s, Surface){
		s.is_selected = true;
		foreach(ModelPolygon &t, s.Polygon)
			s.is_selected &= t.is_selected;
	}
	Notify("Selection");
}

void DataModel::SelectionFromVertices()
{
	foreach(ModelSurface &s, Surface){
		s.is_selected = true;
		foreach(ModelPolygon &t, s.Polygon){
			t.is_selected = true;
			t.view_stage = Vertex[t.Side[0].Vertex].view_stage;
			for (int k=0;k<t.Side.num;k++){
				t.is_selected &= Vertex[t.Side[k].Vertex].is_selected;
				t.view_stage = min(t.view_stage, Vertex[t.Side[k].Vertex].view_stage);
			}
			s.is_selected &= t.is_selected;
		}
	}
	Notify("Selection");
}

void DataModel::SelectOnlySurface(ModelSurface *s)
{
	foreach(ModelSurface &ss, Surface)
		ss.is_selected = (&ss == s);
	SelectionFromSurfaces();
}

ModelPolygon *DataModel::AddTriangle(int a, int b, int c)
{
	Array<int> v;
	v.add(a);
	v.add(b);
	v.add(c);
	Array<vector> sv;
	sv.add(e_y);
	sv.add(v_0);
	sv.add(e_x);
	//ApplyAutoTexturing(this, a, b, c, sv);
	return (ModelPolygon*) Execute(new ActionModelAddPolygonSingleTexture(v, CurrentMaterial, sv));
}

ModelPolygon *DataModel::AddPolygon(Array<int> &v)
{
	Array<vector> sv;
	for (int i=0;i<v.num;i++){
		float w = (float)i / (float)v.num * 2 * pi;
		sv.add(vector(0.5f + cos(w) * 0.5f, 0.5f + sin(w), 0));
	}
	return (ModelPolygon*)Execute(new ActionModelAddPolygonSingleTexture(v, CurrentMaterial, sv));
}

ModelPolygon *DataModel::AddPolygonWithSkin(Array<int> &v, Array<vector> &sv)
{
	return (ModelPolygon*)Execute(new ActionModelAddPolygonSingleTexture(v, CurrentMaterial, sv));
}



int DataModel::get_surf_no(ModelSurface *s)
{
	foreachi(ModelSurface &ss, Surface, i)
		if (&ss == s)
			return i;
	return -1;
}

ModelSurface *DataModel::SurfaceJoin(ModelSurface *a, ModelSurface *b)
{
	msg_db_r("SurfJoin", 1);

	a->TestSanity("Join prae a");
	b->TestSanity("Join prae b");

	int ai = get_surf_no(a);
	int bi = get_surf_no(b);

	// correct edge data of b
	foreach(ModelEdge &e, b->Edge){
		if (e.Polygon[0] >= 0)
			e.Polygon[0] += a->Polygon.num;
		if (e.Polygon[1] >= 0)
			e.Polygon[1] += a->Polygon.num;
	}

	// correct triangle data of b
	foreach(ModelPolygon &t, b->Polygon)
		for (int k=0;k<t.Side.num;k++)
			t.Side[k].Edge += a->Edge.num;

	// correct vertex data of b
	foreach(int v, b->Vertex)
		Vertex[v].Surface = ai;

	// insert data
	a->Vertex.join(b->Vertex);
	a->Edge.append(b->Edge);
	a->Polygon.append(b->Polygon);

	// remove surface
	if (bi >= 0)
		Surface.erase(bi);
	a = &Surface[ai];
	a->TestSanity("Join post a");

	msg_db_l(1);
	return a;
}

void DataModel::ResetAutoTexturing()
{
	if (AutoTexturingData.enabled)
		CurrentMaterial = AutoTexturingData.prev_material;
	AutoTexturingData.enabled = false;
}

void DataModel::ApplyAutoTexturing(int a, int b, int c, vector *sv)
{
	if (AutoTexturingData.enabled){
		vector v[3];
		v[0] = Vertex[a].pos;
		v[1] = Vertex[b].pos;
		v[2] = Vertex[c].pos;
		for (int k=0;k<3;k++)
			sv[k] = vector( (v[k] - AutoTexturingData.p0) * AutoTexturingData.dir_u, (v[k] - AutoTexturingData.p0) * AutoTexturingData.dir_v, 0);
	}
}

void DataModel::CreateSkin(ModelSkin *src, ModelSkin *dst, float quality_factor)
{
	msg_todo("DataModel::CreateSkin");
}




float DataModel::GetDiameter()
{
	float Diameter=0;
	foreach(ModelVertex &v, Vertex){
		float d = v.pos.length() * 2;
		if (d > Diameter)
			Diameter = d;
	}
			/*for (int p2=p1+1;p2<Skin[m].Vertex.num;p2++){
				float d=VecLength(GetVertex(&Skin[m],p1)-GetVertex(&Skin[m],p2));
				if (d>Diameter)
					Diameter=d;
			}*/
	return Diameter;
}

float DetailDistTemp1,DetailDistTemp2,DetailDistTemp3;

int get_num_trias(DataModel *m, ModelSkin *s)
{
	int n = 0;
	for (int i=0;i<m->Material.num;i++)
		n += s->Sub[i].Triangle.num;
	return n;
}

void DataModel::GenerateDetailDists(float *dist)
{
	msg_db_r("GenerateDetailDists", 3);
	float Diameter = GetDiameter();
	dist[0] = Diameter * 5;
	dist[1] = Diameter * 20;
	dist[2] = Diameter * 40;
	if (get_num_trias(this, &Skin[3]) == 0)
		dist[1] = dist[2];
	if (get_num_trias(this, &Skin[2]) == 0)
		dist[0] = dist[1];
	msg_db_l(3);
}


#define n_theta		16

matrix3 DataModel::GenerateInertiaTensor(float mass)
{
	msg_db_r("GenerateInertiaTensor", 3);
//	sModeModelSkin *p = &Skin[0];

	// estimate size
	vector min = v_0, max = v_0;
	foreach(ModelVertex &v, Vertex){
		min._min(v.pos);
		max._max(v.pos);
	}
	/*for (int i=0;i<Ball.num;i++){
		sModeModelBall *b = &Ball[i];
		vector b_min = p->Vertex[b->Index].Pos - vector(1,1,1) * b->Radius;
		vector b_max = p->Vertex[b->Index].Pos + vector(1,1,1) * b->Radius;
		VecMin(min, b_min);
		VecMax(max, b_max);
	}*/
	//msg_write(string2("	min= %f	%f	%f",min.x,min.y,min.z));
	//msg_write(string2("	max= %f	%f	%f",max.x,max.y,max.z));


	//float dv=(max.x-min.x)/n_theta*(max.y-min.y)/n_theta*(max.z-min.z)/n_theta;
	int num_ds=0;

	matrix3 t;
	for (int i=0;i<9;i++)
		t.e[i] = 0;

	for (int i=0;i<n_theta;i++){
		float x=min.x+(float(i)+0.5f)*(max.x-min.x)/n_theta;
		for (int j=0;j<n_theta;j++){
			float y=min.y+(float(j)+0.5f)*(max.y-min.y)/n_theta;
			for (int k=0;k<n_theta;k++){
				float z=min.z+(float(k)+0.5f)*(max.z-min.z)/n_theta;
				vector r=vector(x,y,z);
				//msg_write(string2("%f		%f		%f",r.x,r.y,r.z));

				bool inside=false;
				/*for (int n=0;n<Ball.num;n++){
					sModeModelBall *b=&Ball[n];
					if (VecLength(r-p->Vertex[b->Index].Pos)<b->Radius)
						inside=true;
				}*/
				foreach(ModelSurface &s, Surface)
					if (s.IsInside(r)){
						inside = true;
						break;
					}
				if (inside){
					//msg_write("in");
					num_ds++;
					t._00 += y*y + z*z;
					t._11 += z*z + x*x;
					t._22 += x*x + y*y;
					t._01 -= x*y;
					t._12 -= y*z;
					t._20 -= z*x;
				}
			}
		}
	}

	if (num_ds>0){
		float f = mass / num_ds;
		t *= f;
		t._10 = t._01;
		t._21 = t._12;
		t._02 = t._20;
	}else
		Matrix3Identity(t);

	msg_db_l(3);
	return t;
}


int DataModel::GetNumSelectedVertices()
{
	int r = 0;
	/*if ((CreationMode < 0) && ((SubMode == SubModeSkeleton) || ((SubMode == SubModeAnimation) && (move->Type == MoveTypeSkeletal)))){
		for (int i=0;i<Bone.num;i++)
			if (Bone[i].IsSelected)
				r++;
		return r;
	}*/
	foreach(ModelVertex &v, Vertex)
		if (v.is_selected)
			r ++;
	return r;
}

int DataModel::GetNumSelectedSkinVertices()
{
	int r=0;
	return r;
}

int DataModel::GetNumSelectedPolygons()
{
	int r = 0;
	foreach(ModelSurface &s, Surface)
		foreach(ModelPolygon &t, s.Polygon)
			if (t.is_selected)
				r ++;
	return r;
}

int DataModel::GetNumSelectedSurfaces()
{
	int r = 0;
	foreach(ModelSurface &s, Surface)
		if (s.is_selected)
			r ++;
	return r;
}

int DataModel::GetNumSelectedBones()
{
	int r = 0;
	foreach(ModelBone &b, Bone)
		if (b.is_selected)
			r ++;
	return r;
}

int DataModel::GetNumPolygons()
{
	int r = 0;
	foreach(ModelSurface &s, Surface)
		r += s.Polygon.num;
	return r;
}

ModelSurface* DataModel::AddBall(const vector& pos, float radius, int num_x, int num_y)
{	return (ModelSurface*)Execute(new ActionModelAddBall(pos, radius, num_x, num_y));	}

ModelSurface* DataModel::AddSphere(const vector& pos, float radius, int num)
{	return (ModelSurface*)Execute(new ActionModelAddSphere(pos, radius, num));	}

ModelSurface* DataModel::AddPlane(const vector& pos, const vector& dv1, const vector& dv2, int num_x, int num_y)
{	return (ModelSurface*)Execute(new ActionModelAddPlane(pos, dv1, dv2, num_x, num_y));	}

ModelSurface* DataModel::AddCube(const vector& pos, const vector& dv1, const vector& dv2, const vector& dv3, int num_1, int num_2, int num_3)
{	return (ModelSurface*)Execute(new ActionModelAddCube(pos, dv1, dv2, dv3, num_1, num_2, num_3));	}

ModelSurface* DataModel::AddCylinder(Array<vector>& pos, Array<float> &radius, int rings, int edges, bool closed)
{	return (ModelSurface*)Execute(new ActionModelAddCylinder(pos, radius, rings, edges, closed));	}

ModelSurface *DataModel::AddTorus(const vector &pos, const vector &axis, float radius1, float radius2, int num_x, int num_y)
{	return (ModelSurface*)Execute(new ActionModelAddTorus(pos, axis, radius1, radius2, num_x, num_y));	}

ModelSurface *DataModel::AddPlatonic(const vector &pos, float radius, int type)
{	return (ModelSurface*)Execute(new ActionModelAddPlatonic(pos, radius, type));	}

void DataModel::SetCurrentMove(int move_no)
{
	move = EmptyMove;
	CurrentMove = -1;
	if ((move_no >= 0) && (move_no < Move.num))
		if (Move[move_no].Frame.num > 0){
			move = &Move[move_no];
			CurrentMove = move_no;
		}
	SetCurrentFrame(0);
}

void DataModel::SetCurrentFrame(int frame_no)
{
	if ((frame_no >= 0) && (frame_no < move->Frame.num)){
		CurrentFrame = frame_no;
		UpdateAnimation();
	}
}

void DataModel::SetCurrentFrameNext()
{
	SetCurrentFrame((CurrentFrame + 1) % move->Frame.num);
}

void DataModel::SetCurrentFramePrevious()
{
	SetCurrentFrame((CurrentFrame - 1 + move->Frame.num) % move->Frame.num);
}

void DataModel::AddAnimation(int index, int type)
{	Execute(new ActionModelAddAnimation(index, type));	}

void DataModel::DeleteAnimation(int index)
{	Execute(new ActionModelDeleteAnimation(index));	}

void DataModel::AnimationAddFrame(int index, int frame)
{	Execute(new ActionModelAnimationAddFrame(index, frame));	}

void DataModel::UpdateAnimation()
{
	if (move->Type == MoveTypeSkeletal){
		UpdateSkeleton();
		foreach(ModelVertex &v, Vertex){
			if (v.BoneIndex >= Bone.num)
				v.AnimatedPos = v.pos;
			else
				v.AnimatedPos = Bone[v.BoneIndex].Matrix * (v.pos - GetBonePos(v.BoneIndex));
		}
	}else if (move->Type == MoveTypeVertex){
		int frame0 = CurrentFrame;
		int frame1 = CurrentFrame;
		float t = 0;
		if (Playing){
			frame0 = SimFrame;
			frame1 = (frame0 + 1) % move->Frame.num;
			t = SimFrame - frame0;
		}
		foreachi(ModelVertex &v, Vertex, i){
			v.AnimatedPos = v.pos + (1 - t) * move->Frame[frame0].VertexDPos[i] + t * move->Frame[frame1].VertexDPos[i];
		}
	}else{
		foreach(ModelVertex &v, Vertex){
			v.AnimatedPos = v.pos;
		}
	}
	Notify("Change");
}

void DataModel::UpdateSkeleton()
{
	if (move->Type != MoveTypeSkeletal){
		foreachi(ModelBone &b, Bone, i){
			if (b.Parent < 0)
				b.pos = b.DeltaPos;
			else
				b.pos = Bone[b.Parent].pos + b.DeltaPos;
		}
		return;
	}
	int frame0 = CurrentFrame;
	int frame1 = CurrentFrame;
	float t = 0;
	if (Playing){
		frame0 = SimFrame;
		frame1 = (frame0 + 1) % move->Frame.num;
		t = SimFrame - frame0;
	}

	foreachi(ModelBone &b, Bone, i){
		if (b.Parent < 0){
			b.pos = b.DeltaPos + (1 - t) * move->Frame[frame0].SkelDPos[i] + t * move->Frame[frame1].SkelDPos[i];
		}else{
			vector dp = Bone[b.Parent].Matrix.transform_normal(b.DeltaPos);
			b.pos = Bone[b.Parent].pos + dp;
		}
		matrix trans;
		MatrixTranslation(trans, b.pos);
		quaternion q0, q1, q;
		QuaternionRotationV(q0, move->Frame[frame0].SkelAng[i]);
		QuaternionRotationV(q1, move->Frame[frame1].SkelAng[i]);
		QuaternionInterpolate(q, q0, q1, t);
		MatrixRotationQ(b.RotMatrix, q);
		b.Matrix = trans * b.RotMatrix;
	}
}

vector DataModel::GetBonePos(int index)
{
	if (index < 0)
		return v_0;
	return Bone[index].DeltaPos + GetBonePos(Bone[index].Parent);
}

vector DataModel::GetBonePosAnimated(int index)
{
	return Bone[index].pos;
}

void DataModel::AnimationDeleteFrame(int index, int frame)
{	Execute(new ActionModelAnimationDeleteFrame(index, frame));	}

void DataModel::AnimationDeleteCurrentFrame()
{
	AnimationDeleteFrame(CurrentMove, CurrentFrame);
}

void DataModel::CopyGeometry(ModelGeometry &geo)
{
	geo.clear();

	// copy vertices
	Array<int> vert;
	foreachi(ModelVertex &v, Vertex, vi)
		if (v.is_selected){
			geo.Vertex.add(v);
			vert.add(vi);
		}

	// copy triangles
	foreach(ModelSurface &s, Surface)
		foreach(ModelPolygon &t, s.Polygon)
			if (t.is_selected){
				ModelPolygon tt = t;
				for (int k=0;k<t.Side.num;k++)
					foreachi(int v, vert, vi)
						if (v == t.Side[k].Vertex)
							tt.Side[k].Vertex = vi;
				geo.Polygon.add(tt);
			}
}

void DataModel::DeleteSelection(bool greedy)
{	Execute(new ActionModelDeleteSelection(greedy));	}

void DataModel::InvertSurfaces(const Set<int> &surfaces)
{	Execute(new ActionModelSurfaceInvert(surfaces));	}

void DataModel::InvertSelection()
{	InvertSurfaces(GetSelectedSurfaces());	}

void DataModel::SubtractSelection()
{	Execute(new ActionModelSurfaceSubtract());	}

void DataModel::AlignToGridSelection(float grid_d)
{	Execute(new ActionModelAlignToGrid(this, grid_d));	}

void DataModel::NearifySelectedVertices()
{	Execute(new ActionModelNearifyVertices(this));	}

void DataModel::CollapseSelectedVertices()
{	Execute(new ActionModelCollapseVertices());	}

void DataModel::SetNormalModeSelection(int mode)
{	Execute(new ActionModelSetNormalModeSelection(this, mode));	}

void DataModel::SetNormalModeAll(int mode)
{	Execute(new ActionModelSetNormalModeAll(mode));	}

void DataModel::SetMaterialSelection(int material)
{	Execute(new ActionModelSetMaterial(this, material));	}

void DataModel::PasteGeometry(ModelGeometry& geo)
{	Execute(new ActionModelPasteGeometry(geo));	}

void DataModel::Easify(float factor)
{	Execute(new ActionModelEasify(factor));	}

void DataModel::SubdivideSelectedSurfaces()
{	Execute(new ActionModelSurfacesSubdivide(GetSelectedSurfaces()));	}

void DataModel::BevelSelectedVertices(float radius)
{	Execute(new ActionModelBevelPolygons(radius));	}

void DataModel::FlattenSelectedVertices()
{	Execute(new ActionModelFlattenVertices(this));	}

void DataModel::ExtrudeSelectedPolygons(float offset)
{	Execute(new ActionModelExtrudePolygons(offset));	}

void DataModel::AutoWeldSurfaces(const Set<int> &surfaces, float epsilon)
{	Execute(new ActionModelAutoWeldSelection(epsilon));	}

void DataModel::AutoWeldSelectedSurfaces(float epsilon)
{	Execute(new ActionModelAutoWeldSelection(epsilon));	}

void DataModel::Automap(int material, int texture_level)
{	Execute(new ActionModelAutomap(material, texture_level));	}

void DataModel::AnimationDuplicateCurrentFrame()
{
	AnimationAddFrame(CurrentMove, CurrentFrame + 1);
	SetCurrentFrame(CurrentFrame + 1);
}

void DataModel::SelectionAddEffects(const ModelEffect& effect)
{	Execute(new ActionModelAddEffects(this, effect));	}

void DataModel::EditEffect(int index, const ModelEffect& effect)
{	Execute(new ActionModelEditEffect(index, effect));	}

void DataModel::CutOutSelection()
{	Execute(new ActionModelCutOutPolygons());	}

void DataModel::TriangulateSelection()
{	Execute(new ActionModelTriangulateSelection());	}

void DataModel::MergePolygonsSelection()
{	Execute(new ActionModelMergePolygonsSelection());	}

void DataModel::SelectionClearEffects()
{	Execute(new ActionModelClearEffects(this));	}


void ModelSelectionState::clear()
{
	Vertex.clear();
	Surface.clear();
	Polygon.clear();
}

Set<int> DataModel::GetSelectedVertices()
{
	Set<int> vertex;
	foreachi(ModelVertex &v, Vertex, i)
		if (v.is_selected)
			vertex.add(i);
	return vertex;
}

Set<int> DataModel::GetSelectedSurfaces()
{
	Set<int> surface;
	foreachi(ModelSurface &surf, Surface, i)
		if (surf.is_selected)
			surface.add(i);
	return surface;
}

void DataModel::GetSelectionState(ModelSelectionState& s)
{
	s.clear();
	foreachi(ModelVertex &v, Vertex, i)
		if (v.is_selected)
			s.Vertex.add(i);
	foreachi(ModelSurface &surf, Surface, i){
		if (surf.is_selected)
			s.Surface.add(i);
		Set<int> sel;
		foreachi(ModelPolygon &t, surf.Polygon, j)
			if (t.is_selected)
				sel.add(j);
		s.Polygon.add(sel);
		sel.clear();
		foreachi(ModelEdge &e, surf.Edge, j)
			if (e.is_selected)
				sel.add(j);
		s.Edge.add(sel);
	}
}

void DataModel::SetSelectionState(ModelSelectionState& s)
{
	ClearSelection();
	foreach(int v, s.Vertex)
		Vertex[v].is_selected = true;
	foreach(int si, s.Surface)
		Surface[si].is_selected = true;
	for (int i=0;i<s.Polygon.num;i++)
		foreach(int j, s.Polygon[i])
			Surface[i].Polygon[j].is_selected = true;
	for (int i=0;i<s.Edge.num;i++)
		foreach(int j, s.Edge[i])
			Surface[i].Edge[j].is_selected = true;
	Notify("Selection");
}






/*int DataModel::GetNumMarkedBalls()
{
	int r=0;
	for (int i=0;i<Ball.num;i++)
		if (Ball[i].IsSelected)
			r++;
	return r;
}

int DataModel::GetNumMarkedKonvPolys()
{
	int r=0;
	for (int i=0;i<Poly.num;i++)
		if (Poly[i].IsSelected)
			r++;
	return r;
}*/
