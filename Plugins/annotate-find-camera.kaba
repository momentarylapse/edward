float opt_pain(float[] x, X* u)
	let cam_pos = vector(x[0], x[1], x[2])
	let cam_ang = vector(x[3], x[4], x[5])
	let m = u.projection(cam_pos, cam_ang)
	float pain = 0
	for i in 0:8
		let a = m.project(u.opos[i])
		pain += (a - u.ppos[i]).length_sqr()
	return pain

float[] optimize_step(float[] x0, X* u)
	float dx = 0.0001
	float[] x = x0
	for i in 0:500
		float p0 = opt_pain(x, u)
		float[] dp
		for j in 0:len(x0)
			float[] xx = x
			xx[j] += dx
			dp.add(opt_pain(xx, u) - p0)
		//print(p0)
		dp[3:] *= 0.002
		x -= dp
	//print(x)	
	return x

class X extends Dialog
	Image* im
	vector[] ppos
	vector[] opos
	float scale
	float width, height
	vector cam_pos, cam_ang
	void __init__()
		super.__init__("xxx", 1024, 768, nil, false)
		add_drawing_area("!grabfocus", 0, 0, "area")
		scale = 3
		im = LoadImage("/home/michi/WP_20190408_18_12_15_Pro.png")
		im = im.scale(im.width/scale, im.height/scale)
		ppos = [vector(1812,1372,0), vector(2384,1056,0), vector(1820,1800,0), vector(2376,1452,0),
			vector(1108,916,0), vector(1696,700,0), vector(1168,1344,0), vector(1708,1084,0)]
		for pp in ppos
			pp /= scale
		width = im.width
		height = im.height
		opos = [vector(-17,-12,23), vector(17,-12,23), vector(-17,12,23), vector(17,12,23),
			vector(-17,-12,-23), vector(17,-12,-23), vector(-17,12,-23), vector(17,12,-23)]
		cam_pos = vector(0,0,-120)
		cam_ang = vector(0, 0, 0)
		//let x = [cam_pos.x, cam_pos.y, cam_pos.z, cam_ang.x, cam_ang.y, cam_ang.z]
		//print(opt_pain(x, self))
	
	matrix projection(vector pos, vector ang)
		let view = MatrixTranslation(pos) * MatrixRotationView(ang)
		let proj = MatrixScale(width, height, 1) * MatrixTranslation(vector(0.5, 0.5,0)) * MatrixPerspective(pi/2*0.8, width/height, 10, 1000)
		return proj * view
	override void on_draw(Painter* p)
		p.draw_image(0, 0, *im)
		p.set_color(Red)
		for pp,i in ppos
			p.draw_circle(pp.x, pp.y, 2)
		//	p.draw_str(pp.x,pp.y,"" + i)
		
		let m = projection(cam_pos, cam_ang)
		
		p.set_color(Green)
		vector[] vv
		for pp in opos
			vv.add(m.project(pp))
		for v in vv
			p.draw_circle(v.x, v.y, 5)
			//p.draw_str(v.x,v.y,"" + i)
		for i in 0:2
			for j in 0:2
				p.draw_line(vv[i*4+j*2].x, vv[i*4+j*2].y, vv[i*4+j*2+1].x, vv[i*4+j*2+1].y)
				p.draw_line(vv[i*4+j].x, vv[i*4+j].y, vv[i*4+j+2].x, vv[i*4+j+2].y)
				p.draw_line(vv[i*2+j].x, vv[i*2+j].y, vv[i*2+j+4].x, vv[i*2+j+4].y)
	
	override void on_key_down()
		int k = HuiGetEvent().key_code
		if k == KEY_O
			let x = [cam_pos.x, cam_pos.y, cam_pos.z, cam_ang.x, cam_ang.y, cam_ang.z]
			let y = optimize_step(x, self)
			cam_pos = vector(y[0], y[1], y[2])
			cam_ang = vector(y[3], y[4], y[5])
		redraw("area")
		
		

void main()
	let x = new X()
	x.run()